\subsection{Hybrid Quantum Finite Automata}
\label{sec:hybrid-qfa}

Hybrid quantum finite automata (HQFA) are finite-state machines that combine a quantum state component with a classical state component. In essence, an HQFA consists of a quantum system and a classical finite automaton that operate together, communicating information between them during the computation \cite{li2015hybrid}.

In all these models, the goal is to leverage a small quantum memory together with classical states to recognize languages, potentially with far fewer states than a purely classical automaton would require \cite{zheng2012one}.

Several important hybrid QFA models have been introduced. Ambainis and Watrous \cite{ambainis2002two} first proposed the two-way quantum finite automaton with classical states (\gls{2qcfa}), which augments a two-way deterministic finite automaton with a constant-size quantum register. 

More advanced hybrids include multi-tape extensions like the \gls{2tqcfa} and \gls{ktqcfa}, which increase computational power by leveraging multiple input tapes \cite{zheng2011two}. All one-way hybrid QFA models (\gls{1qcfa}, 1QFAC, \gls{cl-1qfa}) recognize exactly the regular languages \cite{li2015hybrid, zheng2012one}. However, they can be significantly more \textit{succinct} in terms of state complexity than classical models \cite{xiao2021state}.

\subsubsection{\glsentryfull{1qcfa}}

\paragraph{Introduction:}  
The \gls{1qcfa} model, introduced by Zheng, Qiu, Li, and Gruska \cite{zheng2012one}, augments a classical one-way finite automaton with a quantum component. It can be seen as a one-way restriction of the \gls{2qcfa} model. The \gls{1qcfa} features two-way communication between classical and quantum parts: the classical state influences the quantum operation applied, and the quantum measurement outcome affects the next classical state.

\paragraph{Formal Definition:}  
A \gls{1qcfa} is a 9-tuple:
\[
A = (Q, S, \Sigma, C, q_1, s_1, \{\Theta_{s,\sigma}\}, \delta, S_a)
\]
where:
\begin{itemize}
    \item $Q$: finite set of quantum basis states,
    \item $S$: finite set of classical states,
    \item $\Sigma$: input alphabet,
    \item $C$: measurement outcomes,
    \item $q_1 \in Q$, $s_1 \in S$: initial quantum and classical states,
    \item $\Theta_{s,\sigma}$: quantum operation with outcomes in $C$,
    \item $\delta: S \times \Sigma \times C \to S$: classical transition function,
    \item $S_a \subseteq S$: accepting states.
\end{itemize}
Computation begins in $(s_1, |q_1\rangle)$, proceeds symbol-by-symbol. On input $x = x_1x_2\cdots x_n$, the machine updates classical and quantum states based on outcomes $c_i \in C$ generated by each $\Theta_{s_i,x_i}$, applying $\delta(s_i,x_i,c_i)$ at every step. Acceptance is determined by whether the final classical state is in $S_a$ \cite{li2015hybrid}.

\paragraph{Strings Acceptance:}  
A \gls{1qcfa} accepts string $x$ with probability based on outcome paths $c_1c_2\cdots c_n$. If the classical state ends in $S_a$, it accepts. Languages are recognized with bounded error $\varepsilon < 1/2$ if acceptance probability is $\geq 1-\varepsilon$ for all $x \in L$ and $\leq \varepsilon$ for all $x \notin L$ \cite{li2015hybrid, zheng2012one}.

\paragraph{Sets of Languages Recognized:}  
\gls{1qcfa} recognize exactly the class of regular languages \cite{zheng2012one}. Any regular language can be recognized by some \gls{1qcfa} with certainty. Moreover, they can be exponentially more succinct than DFA for some regular languages \cite{xiao2021state}.

\paragraph{Closure Properties:}  
The class of languages recognized by \gls{1qcfa} is closed under union, intersection, and complement, as it coincides with the regular languages \cite{li2015hybrid}.

\paragraph{Advantages and Limitations:}  
While \gls{1qcfa} do not exceed DFA in language power, they are often exponentially more state-efficient. For instance, certain periodic languages can be recognized with a single qubit: rotating the quantum state by $2\pi/p$ for each $a$ and measuring at the end to detect if the state returned to its initial position (full rotation) \cite{xiao2021state, bianchi2014size}.

\paragraph{Comparison Between Models:}  
\gls{1qcfa} generalize \gls{cl-1qfa} and 1QFAC. The main difference lies in bidirectional communication. In comparison to \gls{2qcfa}, \gls{1qcfa} are weaker, since they cannot move backward on the input or recognize non-regular languages \cite{li2015hybrid}.

\paragraph{Example:}  
A \gls{1qcfa} can recognize the language $L = \{ a^n : n \equiv 0 \mod p \}$ using a single qubit: rotating the quantum state by $2\pi/p$ for each $a$ and measuring at the end to detect if the state returned to its initial position (full rotation) \cite{bianchi2014power}.

\paragraph{Additional Topics:}  
\gls{1qcfa} equivalence is decidable \cite{li2015hybrid}. State trade-offs between classical and quantum resources have been studied extensively \cite{qiu2009equivalence, xiao2021state}. Future work includes refining state complexity bounds and exploring minimal configurations.


\subsubsection{\glsentryfull{cl-1qfa}}

\paragraph{Introduction:}  
The \gls{cl-1qfa} (Quantum Finite Automata with Control Language) model, introduced by Bertoni, Mereghetti, and Palano \cite{mereghetti2006quantum}, consists of a quantum component responsible for unitary operations and measurements, and a classical DFA that processes the sequence of measurement outcomes. The role of the control language is to guide acceptance: a word is accepted if and only if the sequence of measurement outcomes belongs to a regular language defined by the control automaton.

\paragraph{Formal Definition:}  
A \gls{cl-1qfa} is a 6-tuple:
\[
A = (Q, \Sigma, \{U_\sigma\}_{\sigma \in \Sigma}, q_0, M, L)
\]
where:
\begin{itemize}
    \item $Q$: finite set of quantum basis states,
    \item $\Sigma$: input alphabet,
    \item $U_\sigma$: unitary transformation applied upon reading symbol $\sigma$,
    \item $q_0 \in Q$: initial quantum state,
    \item $M$: projective measurement with outcomes in a finite set $\Gamma$,
    \item $L \subseteq \Gamma^*$: regular control language recognized by a classical DFA.
\end{itemize}
On input $x = x_1x_2\cdots x_n$, the automaton applies $U_{x_i}$ and measures after each step, producing an output string $y \in \Gamma^n$. The word $x$ is accepted if $y \in L$.

\paragraph{Strings Acceptance:}  
Acceptance depends entirely on whether the sequence of quantum measurement results belongs to the control language $L$. This model generally uses bounded-error acceptance. However, exact acceptance is possible for certain languages, depending on the control DFA and quantum measurements \cite{mereghetti2006quantum}.

\paragraph{Sets of Languages Recognized:}  
\gls{cl-1qfa} recognize exactly the class of regular languages \cite{li2015hybrid}. Though they do not surpass the regular class in power, their structure allows for different expressive strategies by decoupling quantum operations from classical verification.

\paragraph{Closure Properties:}  
The class of languages recognized is closed under union, intersection, and complement because the control language is regular and the measurement outcomes are deterministic modulo quantum probabilities \cite{li2015hybrid}.

\paragraph{Advantages and Limitations:}  
Advantages include clear separation between quantum processing and classical control, which simplifies modular design and analysis. The main limitation is that the model cannot recognize non-regular languages and does not allow dynamic feedback between quantum and classical components \cite{li2015hybrid}.

\paragraph{Comparison Between Models:}  
\gls{cl-1qfa} can be simulated by \gls{1qcfa} \cite{li2015hybrid}, but not vice versa. Unlike \gls{1qcfa}, \gls{cl-1qfa} do not allow two-way communication: measurement outcomes do not affect the ongoing quantum state. This makes \gls{cl-1qfa} structurally simpler, but less expressive in practice.

\paragraph{Example:}  
To recognize $L = (ab)^*$, a \gls{cl-1qfa} can measure each input symbol’s quantum effect and produce a binary output: `0` for $a$, `1` for $b$. The control DFA can then accept only if the output string alternates properly and has even length \cite{mereghetti2006quantum}.

\paragraph{Additional Topics:}  
Variants of \gls{cl-1qfa} using unary control languages have been recently proposed to explore succinctness and unary acceptance conditions \cite{mereghetti2024unary}. These help analyze minimal state configurations and potential hardware implementations.


\subsubsection{\glsentryfull{2qcfa}}

\paragraph{Introduction:}  
The \gls{2qcfa} model, introduced by Ambainis and Watrous \cite{ambainis2002two}, is a hybrid automaton that consists of a classical two-way deterministic finite control and a constant-size quantum register. It was designed to exploit quantum computation while maintaining classical control over input movement. This makes the model both powerful and physically realizable, allowing the classical part to handle head movement and state tracking, while the quantum component processes information probabilistically.

\paragraph{Formal Definition:}  
A \gls{2qcfa} is a 9-tuple:
\[
A = (Q, S, \Sigma, \Theta, \delta, q_0, s_0, S_a, S_r)
\]
where:
\begin{itemize}
    \item $Q$: finite set of quantum basis states,
    \item $S$: finite set of classical states,
    \item $\Sigma$: input alphabet,
    \item $\Theta$: quantum transition function defining unitary operators or measurements,
    \item $\delta$: classical transition function based on current state, symbol, and measurement outcome,
    \item $q_0 \in Q$, $s_0 \in S$: initial quantum and classical states,
    \item $S_a$, $S_r$: sets of accepting and rejecting classical states.
\end{itemize}
The classical control can move the tape head both left and right. The quantum state is manipulated via unitary transformations or measurements, which are determined by the classical state and scanned symbol. Decisions are made based on both the classical and quantum information.

\paragraph{Strings Acceptance:}  
\gls{2qcfa} accept strings using bounded error or with one-sided error. For example, languages like $L_{eq} = \{ a^n b^n \mid n \geq 1 \}$ can be accepted with one-sided bounded error in expected polynomial time \cite{ambainis2002two}.

\paragraph{Sets of Languages Recognized:}  
\gls{2qcfa} can recognize certain non-regular languages, including $L_{eq}$ and palindromes over unary alphabets, which makes them strictly more powerful than classical DFA or one-way QFA \cite{ambainis2002two, li2015hybrid}.

\paragraph{Closure Properties:}  
The class of languages recognized by \gls{2qcfa} is not closed under union or intersection, due to the constraints of the probabilistic error bounds and two-way head movement. However, they maintain closure under reversal and concatenation in specific cases \cite{li2015hybrid}.

\paragraph{Advantages and Limitations:}  
Advantages include greater recognition power than \gls{1qcfa} and succinctness for certain problems. For example, \gls{2qcfa} can recognize $L_{eq}$ with only a constant-size quantum register and logarithmic classical states \cite{remscrim2020power}. However, they are generally limited to languages where probabilistic techniques suffice, and their runtime is often polynomial in the worst case \cite{remscrim2020lower}.

\paragraph{Comparison Between Models:}  
\gls{2qcfa} generalize \gls{1qcfa} by allowing two-way head movement, which significantly increases computational power. In contrast to \gls{cl-1qfa}, they use dynamic feedback from the quantum measurements to the classical state transitions. \gls{2qcfa} are more expressive but harder to analyze due to interaction complexity \cite{zheng2013state}.

\paragraph{Example:}  
The language $L_{eq} = \{ a^n b^n \mid n \geq 1 \}$ can be recognized by a \gls{2qcfa} by using the quantum register to randomly check positions and probabilistically verify balance between $a$'s and $b$'s through repeated subroutines \cite{ambainis2002two}.

\paragraph{Additional Topics:}  
Future work includes better understanding the time complexity of \gls{2qcfa} algorithms and developing minimization techniques. Variants include alternating \gls{2qcfa} and state-succinct encodings \cite{zheng2013state, remscrim2020lower}.

\subsubsection{\glsentryfull{2tqcfa}}

\paragraph{Introduction:}  
The \gls{2tqcfa} model (Two-Tape Quantum-Classical Finite Automata) extends the \gls{2qcfa} by using two input tapes instead of one. Introduced by Zheng, Li, and Qiu \cite{zheng2011two}, this model enhances computational power by enabling comparisons and synchronized traversal of two input strings. The quantum component remains fixed in size, while the classical controller can move the heads on both tapes and perform transitions based on measurements.

\paragraph{Formal Definition:}  
A \gls{2tqcfa} is formally a tuple similar to a \gls{2qcfa} but with two input tapes:
\[
A = (Q, S, \Sigma, \Theta, \delta, q_0, s_0, S_a, S_r)
\]
with the following distinctions:
\begin{itemize}
    \item Two input heads, each reading a separate string from $\Sigma^*$,
    \item Classical state $s \in S$ determines movement and operation on each tape head,
    \item Quantum operations $\Theta$ depend on the symbols scanned by both heads and classical state.
\end{itemize}
As in \gls{2qcfa}, the automaton evolves through interactions between classical and quantum transitions, but the two-tape structure allows for cross-input comparisons.

\paragraph{Strings Acceptance:}  
\gls{2tqcfa} can accept languages using bounded-error acceptance, typically with one-sided error. A notable example includes the language $L = \{ w \# w \mid w \in \{a, b\}^* \}$, which is non-regular and not recognizable by \gls{2qcfa}, but accepted by \gls{2tqcfa} using synchronous traversal of both input halves \cite{zheng2011two}.

\paragraph{Sets of Languages Recognized:}  
The language recognition power of \gls{2tqcfa} includes certain context-free and non-regular languages not recognizable by \gls{2qcfa}. Thus, \gls{2tqcfa} strictly extends the power of \gls{2qcfa} under bounded-error acceptance \cite{zheng2011two}.

\paragraph{Closure Properties:}  
Due to the added complexity of two-tape processing, closure properties are less well-defined. However, the model is still limited by finite memory and cannot recognize arbitrary context-free languages \cite{li2015hybrid}.

\paragraph{Advantages and Limitations:}  
The primary advantage is an increased ability to perform input comparisons, useful for palindromes or equality checks. The main limitations include increased implementation complexity and difficulties in analyzing language classes and performance bounds.

\paragraph{Comparison Between Models:}  
\gls{2tqcfa} extend \gls{2qcfa} in power by enabling comparisons across two tapes. Unlike kTQCFA (which generalize even further), \gls{2tqcfa} remain practical for checking mirrored or related substrings. Compared to \gls{1qcfa} and \gls{cl-1qfa}, they are significantly more powerful in terms of language recognition.

\paragraph{Example:}  
To recognize $L = \{ w \# w \}$, a \gls{2tqcfa} reads $w$ on the first tape and stores information in the quantum register. It then compares this with the second half of the input on the second tape. Probabilistic subroutines are used to ensure correctness with bounded error \cite{zheng2011two}.

\paragraph{Additional Topics:}  
Variants of multi-tape quantum automata have been studied to explore even richer classes. Open problems include characterizing all non-regular languages recognizable by \gls{2tqcfa} with polynomial expected runtime.


\subsubsection{\glsentryfull{ktqcfa}}

\paragraph{Introduction:}  
The \gls{ktqcfa} model generalizes the two-tape quantum-classical automaton to an arbitrary finite number $k$ of input tapes. This model, proposed in subsequent works building upon the \gls{2tqcfa} model \cite{zheng2011two}, enhances the automaton’s ability to process complex language patterns by allowing simultaneous access to multiple strings. Each tape is read by an independent head, all coordinated by a classical control unit and a constant-size quantum register.

\paragraph{Formal Definition:}  
A \gls{ktqcfa} is defined similarly to a \gls{2tqcfa} but with $k$ tapes and $k$ input heads. The formal components include:
\[
A = (Q, S, \Sigma, \Theta, \delta, q_0, s_0, S_a, S_r)
\]
with modifications:
\begin{itemize}
    \item $k$ input tapes, each with its own head,
    \item Classical state transitions $\delta$ depend on the symbols read from all $k$ heads and outcomes of quantum operations,
    \item Quantum transitions $\Theta$ may vary based on any combination of input symbols and classical state.
\end{itemize}
The automaton reads the tapes simultaneously and updates its classical and quantum states accordingly, with acceptance determined by reaching a state in $S_a$.

\paragraph{Strings Acceptance:}  
Acceptance is based on bounded-error criteria. This model can accept languages requiring coordinated comparisons across multiple strings, such as interleaving or mirror structures, which are beyond the capability of \gls{2qcfa} or \gls{2tqcfa}.

\paragraph{Sets of Languages Recognized:}  
\gls{ktqcfa} can recognize certain languages that lie outside the class of regular and some context-free languages. It provides a hierarchical extension in power with increasing $k$, where $k=1$ corresponds to \gls{1qcfa} and $k=2$ to \gls{2tqcfa} \cite{li2015hybrid}.

\paragraph{Closure Properties:}  
Due to increasing complexity with larger $k$, closure properties are less explored. They inherit the limited closure of \gls{2tqcfa} but allow more expressive constructions for language families.

\paragraph{Advantages and Limitations:}  
The main advantage of \gls{ktqcfa} is scalability of pattern comparison and cross-tape logic. However, this comes at a cost: managing multiple heads and quantum-classical interactions becomes increasingly complex, both analytically and in potential physical realization.

\paragraph{Comparison Between Models:}  
\gls{ktqcfa} generalize all previously discussed models. While more powerful, they are also less practical for current quantum computing technologies. Unlike \gls{1qcfa} or \gls{cl-1qfa} which are implementable with simpler setups, \gls{ktqcfa} require sophisticated synchronization mechanisms.

\paragraph{Example:}  
A 3TQCFA can accept a language like $L = \{ (x, y, z) \mid x = y = z \}$ by comparing the three inputs simultaneously, performing probabilistic checks using quantum subroutines and classical tracking over each input position.

\paragraph{Additional Topics:}  
Future work may include classification of languages based on minimal $k$ required, complexity of simulations by smaller models, and physical feasibility of multi-tape implementations in quantum automata.