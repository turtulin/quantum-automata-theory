\chapter{Literature Review}
\label{chap:chapter3}

\section{One-way QFAs}
\label{sec:one-way-qfas}

\subsection{Standard Models}
\label{subsec:standard-models}

\subsubsection{MO-1QFA (Measure-Once)}
\label{sssec:mo-1qfa}

\textbf{Definition}: An MO-1QFA is defined as \( M = (Q, \Sigma, \delta, q_0, F) \), where:
- \( Q \): Finite set of quantum basis states.
- \( \Sigma \): Input alphabet with end-marker \( \# \).
- \( \delta \): Transition function inducing unitary operators \( U_\sigma \) for \( \sigma \in \Sigma \).
- \( q_0 \in Q \): Initial state.
- \( F \subseteq Q \): Accepting states \cite{moore2000quantum}.

\textbf{Operation}: Processes input sequentially with a single measurement at the end. The state evolves as \( |\psi_i\rangle = U_{\sigma_i}|\psi_{i-1}\rangle \). Acceptance is determined by projecting onto \( F \) \cite{moore2000quantum}.

\textbf{Key Features}:
- Recognizes a strict subset of regular languages (e.g., periodic languages) \cite{bertoni2001regular}.
- Requires \( O(n) \) states for languages like \( L_{\text{mod}} = \{w \mid |w| \equiv 0 \mod p\} \).

\textbf{Limitations}: 
- Cannot recognize non-regular languages like \( L_{\text{eq}} = \{a^n b^n\} \).

\subsubsection{MM-1QFA (Measure-Many)}
\label{sssec:mm-1qfa}

\textbf{Definition}: An MM-1QFA is \( M = (Q, \Sigma, \delta, q_0, Q_{\text{acc}}, Q_{\text{rej}}, Q_{\text{non}}) \), where:
- \( Q_{\text{acc}}, Q_{\text{rej}}, Q_{\text{non}} \): Partitioned states for halting and continuation \cite{kondacs1997power}.

\textbf{Operation}: Measures after each symbol, halting if \( Q_{\text{acc}} \) or \( Q_{\text{rej}} \) is observed \cite{kondacs1997power}.

\textbf{Key Features}:
- Recognizes non-regular languages (e.g., \( L_{\text{eq}} \)) with bounded error \cite{kondacs1997power}.
- Exponential state advantage over DFAs for certain languages \cite{ambainis2009superiority}.

\textbf{Limitations}: 
- Strictly less powerful than two-way QFAs \cite{ambainis2009superiority}.

\subsubsection{LQFA (Latvian)}
\label{sssec:lqfa}

\textbf{Definition}: Combines unitary operations and projective measurements. Defined as \( M = (Q, \Sigma, \delta, q_0, F) \), where transitions include measurements \cite{ambainis2002quantum}.

\textbf{Operation}: Applies unitary transformations followed by projective measurements at each step \cite{ambainis2002quantum}.

\textbf{Key Features}:
- Recognizes a proper subset of MM-1QFA languages \cite{ambainis2002quantum}.
- Fails to recognize regular languages like \( a\Sigma^* \).

\textbf{Limitations}: 
- Weaker closure properties compared to MM-1QFA \cite{ambainis2002quantum}.

\subsection{Hybrid Models}
\label{subsec:hybrid-models}

\subsubsection{1QFAC (Classical States)}
\label{sssec:1qfac}

\textbf{Definition}: \( M = (S, Q, \Sigma, \delta, \mu, s_0, q_0, F) \), combining classical control \( S \) and quantum states \( Q \) \cite{zheng2012one}.

\textbf{Operation}: Classical state \( s_i \) selects quantum operator \( \mu(s_i, \sigma) \). Measurement occurs only at the end \cite{zheng2012one}.

\textbf{Key Features}:
- Recognizes all regular languages and some non-regular languages (e.g., \( L_{\text{eq}} \)) \cite{zheng2012one}.
- Exponentially more succinct than DFAs for certain languages \cite{bianchi2014size}.

\textbf{Limitations}: 
- Requires careful error correction due to quantum-classical interaction \cite{zheng2012one}.

\subsubsection{CL-1QFA (Control Languages)}
\label{sssec:cl-1qfa}

\textbf{Definition}: Uses control languages to guide measurements. Defined as \( M = (Q, \Sigma, \delta, q_0, \mathcal{L}) \), where \( \mathcal{L} \) specifies allowed measurement outcomes \cite{bertoni2003quantum}.

\textbf{Operation}: Applies unitary operations and projects onto subspaces dictated by \( \mathcal{L} \) \cite{bertoni2003quantum}.

\textbf{Key Features}:
- Closed under Boolean operations \cite{bertoni2003quantum}.
- Recognizes regular languages with bounded error \cite{bertoni2003quantum}.

\textbf{Limitations}: 
- Complex control logic increases implementation overhead \cite{bertoni2003quantum}.

\subsection{Enhanced Models}
\label{subsec:enhanced-models}

\subsubsection{EQFA (Enhanced)}
\label{sssec:eqfa}

\textbf{Definition}: Uses ancilla qubits and arbitrary measurements. Defined as \( M = (\Sigma, Q, \{U_\sigma\}, Q_{\text{acc}}, Q_{\text{rej}}, Q_{\text{non}}, q_0) \) \cite{paschen2000quantum}.

\textbf{Operation}: Employs mixed states and non-unitary transitions for enhanced expressiveness \cite{paschen2000quantum}.

\textbf{Key Features}:
- Simulates all classical finite automata \cite{paschen2000quantum}.
- Recognizes non-regular languages with unbounded error \cite{nayak1999optimal}.

\textbf{Limitations}: 
- Irreversible operations complicate error analysis \cite{nayak1999optimal}.

\subsubsection{OT-QFA (Open-Time Evolution)}
\label{sssec:ot-qfa}

\textbf{Definition}: Incorporates environmental noise via Lindblad dynamics. Defined as \( M = (\Sigma, Q, \mathcal{L}, q_0, F) \), where \( \mathcal{L} \) models decoherence \cite{hirvensalo2012quantum}.

\textbf{Operation}: State evolution governed by the Lindblad equation, with measurement at the end \cite{hirvensalo2012quantum}.

\textbf{Key Features}:
- Generalizes MO-1QFA and MM-1QFA \cite{hirvensalo2012quantum}.
- Models realistic noisy systems \cite{breuer2002theory}.

\textbf{Limitations}: 
- Undecidable properties due to open-system dynamics \cite{hirvensalo2012quantum}.

\subsubsection{A-QFA (Ancilla-Based)}
\label{sssec:a-qfa}

\textbf{Definition}: Extends MO-1QFA with ancilla qubits. Defined as \( M = (Q, \Sigma, \delta, q_0, F) \) with an expanded Hilbert space \cite{paschen2000quantum}.

\textbf{Operation}: Uses ancillae to simulate classical nondeterminism via quantum interference \cite{paschen2000quantum}.

\textbf{Key Features}:
- Recognizes all regular languages with certainty \cite{paschen2000quantum}.
- Handles non-regular languages with one-sided error \cite{paschen2000quantum}.

\textbf{Limitations}: 
- Ancilla management increases resource overhead \cite{paschen2000quantum}.

\subsection{Advanced Variants}
\label{subsec:advanced-variants}

\subsubsection{1.5QFA (1.5-Way)}
\label{sssec:1.5qfa}

\textbf{Definition}: Allows limited head movement. Defined as \( M = (Q, \Sigma, \delta, q_0, F) \), where \( \delta \) restricts leftward motion \cite{kondacs1997power}.

\textbf{Operation}: Head moves right or remains stationary but cannot backtrack fully \cite{kondacs1997power}.

\textbf{Key Features}:
- Recognizes non-regular languages with bounded error \cite{kondacs1997power}.
- Strictly more powerful than MO-1QFA \cite{kondacs1997power}.

\textbf{Limitations}: 
- Less powerful than 2QFA \cite{kondacs1997power}.

\subsubsection{ML-QFA (Multi-Letter)}
\label{sssec:ml-qfa}

\textbf{Definition}: Reads \( k \)-symbol blocks. Defined as \( M = (Q, \Sigma, \delta, q_0, F) \), where \( \delta \) depends on \( k \)-length substrings \cite{belovs2007multi}.

\textbf{Operation}: Processes input in chunks, applying unitary operators for each block \cite{belovs2007multi}.

\textbf{Key Features}:
- Simulates multi-head classical automata \cite{belovs2007multi}.
- Recognizes context-sensitive languages with bounded error \cite{belovs2007multi}.

\textbf{Limitations}: 
- State complexity grows exponentially with \( k \) \cite{belovs2007multi}.
% \chapter{Literature Review}
% \label{chap:chapter3}
% \section{One-way QFAs}
% \subsection{Standard Models}
% \subsubsection{MO-1QFA (Measure-Once)}
% \subsubsection{MM-1QFA (Measure-Many)}
% \subsubsection{LQFA (Latvian)}
% \subsection{Hybrid Models}
% \subsubsection{1QFAC (Classical States)}
% \subsubsection{CL-1QFA (Control Languages)}
% \subsection{Enhanced Models}
% \subsubsection{EQFA (Enhanced)}
% \subsubsection{OT-QFA (Open-Time Evolution)}
% \subsubsection{A-QFA (Ancilla-Based)}
% \subsection{Advanced Variants}
% \subsubsection{1.5QFA (1.5-Way)}
% \subsubsection{ML-QFA (Multi-Letter)}

\section{Two-way QFAs}
\label{sec:two-way-qfas}

\subsection{Standard Models}
\label{subsec:two-way-standard}

\subsubsection{2QFA (Two-Way)}
\label{sssec:2qfa}

\textbf{Definition}: A 2QFA is defined as \( M = (Q, \Sigma, \delta, q_0, Q_{\text{acc}}, Q_{\text{rej}}) \), where:
- \( Q \): Finite set of quantum states partitioned into \( Q_{\text{acc}} \), \( Q_{\text{rej}} \), and \( Q_{\text{non}} \).
- \( \Sigma \): Input alphabet with end-markers \( \# \) (left) and \( \$ \) (right).
- \( \delta \): Transition function defining unitary operators and head movements \( \{ \leftarrow, \rightarrow, \downarrow \} \) \cite{kondacs1997power}.

\textbf{Operation}: The head moves bidirectionally over the input tape. For input \( w = \sigma_1\sigma_2\ldots\sigma_n \), the state evolves as \( |\psi_i\rangle = U_{\sigma_i} |\psi_{i-1}\rangle \), with intermediate measurements allowed \cite{kondacs1997power}.

\textbf{Key Features}:
- Recognizes non-regular languages (e.g., \( L_{\text{eq}} = \{a^n b^n\} \)) with bounded error in linear time \cite{kondacs1997power}.
- Solves the word problem for finitely generated groups \cite{ambainis2002quantum}.

\textbf{Limitations}: 
- Requires quantum registers scaling with input length, complicating physical implementation \cite{ambainis2002quantum}.

\subsection{Hybrid Models}
\label{subsec:two-way-hybrid}

\subsubsection{2QCFA (Classical States)}
\label{sssec:2qcfa}

\textbf{Definition}: Combines classical control and quantum states. Defined as \( M = (S, Q, \Sigma, \Theta, \delta, s_0, q_0, S_{\text{acc}}, S_{\text{rej}}) \), where:
- \( S \): Classical states controlling transitions.
- \( Q \): Quantum states for superposition/mixed states \cite{ambainis2002quantum}.

\textbf{Operation}: Classical states \( S \) select quantum operations \( \Theta \), while \( \delta \) governs head movement. Measurements occur adaptively based on classical control \cite{ambainis2002quantum}.

\textbf{Key Features}:
- Recognizes \( L_{\text{eq}} \) and palindromes \( L_{\text{pal}} = \{ww^R\} \) in polynomial time with constant quantum states \cite{ambainis2002quantum}.
- Simulates classical 2PFAs while recognizing non-regular languages \cite{zheng2012one}.

\textbf{Limitations}: 
- Decidability of equivalence between 2QCFAs remains open \cite{zheng2012one}.

\subsection{Multihead/Tape Extensions}
\label{subsec:multihead-tape}

\subsubsection{2TQCFA (Two-Tape)}
\label{sssec:2tqcfa}

\textbf{Definition}: Extends 2QCFA with two tapes. Defined as \( M = (S, Q, \Sigma_1 \times \Sigma_2, \Theta, \delta, s_0, q_0, S_{\text{acc}}, S_{\text{rej}}) \), where:
- \( \Sigma_1, \Sigma_2 \): Input alphabets for two tapes.
- \( \delta \): Governs synchronized head movements on both tapes \cite{zheng2012two}.

\textbf{Operation}: Processes inputs on two tapes simultaneously, enabling verification of relationships like \( L = \{a^n b^n c^n\} \) \cite{zheng2012two}.

\textbf{Key Features}:
- Recognizes languages beyond the capabilities of single-tape 2QFAs \cite{zheng2012two}.
- Verifies non-context-free languages in polynomial time \cite{zheng2012two}.

\textbf{Limitations}: 
- Increased complexity in synchronization and error correction \cite{zheng2012two}.

\subsubsection{kTQCFA (k-Tape)}
\label{sssec:ktqcfa}

\textbf{Definition}: Generalizes 2TQCFA to \( k \) tapes. Defined as \( M = (S, Q, \bigtimes_{i=1}^k \Sigma_i, \Theta, \delta, s_0, q_0, S_{\text{acc}}, S_{\text{rej}}) \) \cite{zheng2012two}.

\textbf{Operation}: Coordinates \( k \) independent tapes for parallel processing, useful for multi-variable language recognition \cite{zheng2012two}.

\textbf{Key Features}:
- Recognizes \( L = \{a^n b^{n^2}\} \) with \( O(\log n) \) quantum states \cite{zheng2012two}.
- Subsumes classical multi-tape automata in efficiency \cite{zheng2012two}.

\textbf{Limitations}: 
- Practical implementation constrained by tape synchronization overhead \cite{zheng2012two}.

% \section{Two-way QFAs}
% \subsection{Standard Models}
% \subsubsection{2QFA (Two-Way)}
% \subsection{Hybrid Models}
% \subsubsection{2QCFA (Classical States)}
% \subsection{Multihead/Tape Extensions}
% \subsubsection{2TQCFA (Two-Tape)}
% \subsubsection{kTQCFA (k-Tape)}

\section{Interactive Quantum Automata}
\label{sec:interactive-quantum}

\subsubsection{QIP (Quantum Interactive Proofs)}
\label{sssec:qip}

\textbf{Definition}: A \textit{Quantum Interactive Proof} (QIP) system involves a polynomial-time quantum verifier \( V \) interacting with an unbounded quantum prover \( P \) via a shared quantum channel. The verifier is modeled as a quantum finite automaton (QFA) with limited memory \cite{zheng2015power}. Formally, \( \text{QIP}(k) \) denotes systems with \( k \) rounds of interaction \cite{nishimura2009application}.

\textbf{Operation}: The verifier processes input \( w \) through alternating rounds of quantum communication with the prover. For 1QFA/2QFA verifiers, transitions are governed by:
\[
\delta: Q \times \Sigma \times \Gamma \to \mathbb{C}^{Q \times Q},
\]
where \( \Gamma \) is the communication alphabet \cite{zheng2015power}. Acceptance is determined by measuring the verifier's final state.

\textbf{Key Features}:
- \( \text{QIP} = \text{PSPACE} \) [[1], [2]], demonstrating equivalence to classical interactive proofs.
- QFA-based verifiers (e.g., 2QFA) recognize languages beyond regular classes with bounded error \cite{nishimura2009application}.
- Two-message QIP systems (\( \text{QIP}(2) \)) are contained in \( \text{PSPACE} \) <button class="citation-flag" data-index="1">.

\textbf{Limitations}: 
- Requires precise control over quantum communication channels \cite{zheng2015power}.
- Verifier's state complexity scales with input length for non-regular languages \cite{nishimura2009application}.

\subsubsection{QMIP (Quantum Merlin-Arthur)}
\label{sssec:qmip}

\textbf{Definition}: \textit{Quantum Merlin-Arthur} (QMIP) extends QIP to multiple quantum provers (\( k \geq 2 \)) who cannot communicate. Defined as \( \text{QMIP}(k) \), it allows entangled provers but restricts collusion \cite{scegulnaja2010postselection}.

\textbf{Operation}: Merlin (prover) sends a quantum witness state \( |\psi\rangle \) to Arthur (verifier). For 2QFA verifiers, the transition function validates \( |\psi\rangle \) via:
\[
\delta: Q \times \Sigma \times \mathcal{H}_\text{wit} \to \mathbb{C}^{Q \times Q},
\]
where \( \mathcal{H}_\text{wit} \) is the witness Hilbert space \cite{yamakami2014constant}.

\textbf{Key Features}:
- \( \text{QMIP} = \text{MIP}^* \), enabling recognition of languages beyond \( \text{QIP} \) <button class="citation-flag" data-index="10">.
- Recognizes the palindrome language \( L_{\text{pal}} = \{ww^R\} \) with entangled provers \cite{scegulnaja2010postselection}.
- 2QFA verifiers with QMIP achieve exponential state savings over classical MIP systems \cite{zheng2015power}.

\textbf{Limitations}: 
- Entanglement between provers introduces verification complexity \cite{yamakami2014constant}.
- \( \text{QMIP}(1\text{QFA}) \neq \text{QIP}(1\text{QFA}) \) in polynomial time \cite{nishimura2009application}.

% \section{Interactive Quantum Automata}
% \subsubsection{QIP (Quantum Interactive Proofs)}
% \subsubsection{QMIP (Quantum Merlin-Arthur)}
