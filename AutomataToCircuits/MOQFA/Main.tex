\section{Measure-Once One-Way Quantum Finite Automaton to Circuit}
\label{sec:moqfa-to-circuit}

The formalism of quantum finite automata, particularly the measure-once variant,
offers a high-level abstract framework for modelling quantum computations over
strings.
Quantum circuits, in contrast, constitute a concrete, physically realisable model
that can be executed on quantum hardware.
Bridging the two allows one to encode automaton-based algorithms into circuits.
In what follows we map every component of a
Measure-Once One-Way Quantum Finite Automaton (MO-1QFA)
to a circuit element, give a general compilation
algorithm, and illustrate the procedure step-by-step with examples.

\subsection{Mapping Automaton Components to Circuit Elements}

A MO-1QFA is a tuple
\[
  A = (Q,\Sigma,\delta,q_0,F),
\]
where $Q$ is a finite set of states, $\Sigma$ the input alphabet,
$\delta$ the transition function (unitaries $\{U_\sigma\}_{\sigma\in\Sigma}$),
$q_0\in Q$ the initial state and $F\subseteq Q$ the set of accepting states.
Each component is realised in a circuit as follows.

\begin{enumerate}[leftmargin=*,label=\textbf{\arabic*.}]
\item \emph{Quantum states $Q$ and number of qubits}.  
      Choose $n=\lceil\log_2|Q|\rceil$.
      Every $q\in Q$ is encoded as a computational basis vector
      $\ket{q}$ of an $n$-qubit register.

\item \emph{Alphabet $\Sigma$}.  
      Each symbol $\sigma$ is matched with a unitary $U_\sigma$ on the
      state register.

\item \emph{Transition function $\delta$}.  
      For fixed $\sigma$, $\delta$ is the $|Q|\times|Q|$ matrix $U_\sigma$.
      Each $U_\sigma$ is later decomposed into gates from a universal
      set (e.g.\ Clifford+T or $\{\textsf{CNOT},R_z\}$).

\item \emph{Initial state $q_0$}.  
      The register starts in $\ket{0}^{\otimes n}$ and is prepared
      to $\ket{q_0}$ (often by a few $X$ gates if $\ket{q_0}$ is a basis
      vector).

\item \emph{Final states $F$ and measurement}.  
      After all symbols are processed a two-outcome
      projective measurement
      $\{P_{\text{acc}},I-P_{\text{acc}}\}$ with
      \(
        P_{\text{acc}}=\sum_{q\in F}\ket{q}\!\bra{q}
      \)
      distinguishes accepting from non-accepting sub-spaces,
      outputting $1$ (accept) or $0$ (reject).
\end{enumerate}

\vspace{6pt}
\begin{table}[ht]
\centering
\footnotesize
\begin{tabularx}{\textwidth}{>{\raggedright\arraybackslash}p{0.15\textwidth}%
                        >{\raggedright\arraybackslash}p{0.20\textwidth}X}
\toprule
\textbf{Automaton part} & \textbf{Circuit realisation} & \textbf{Explanation}\\
\midrule
$Q$          & $n$-qubit basis        & Encode each $q\in Q$ as $\ket{q}$, with $n=\lceil\log_2|Q|\rceil$.\\
$\Sigma$     & unitary $U_\sigma$     & Reading $\sigma$ applies $U_\sigma$.\\
$\delta$     & set $\{U_\sigma\}$     & Transition matrices later decomposed into elementary gates.\\
$q_0$        & state $\ket{q_0}$      & Prepare register from $\ket{0}^{\otimes n}$ to $\ket{q_0}$.\\
$F$          & projector $P_{\text{acc}}$ & Measure $\{P_{\text{acc}},I-P_{\text{acc}}\}$ for accept/reject.\\
\bottomrule
\end{tabularx}
\caption{Mapping MO-1QFA components to quantum-circuit constructs.}
\label{tab:moqfa-mapping-new}
\end{table}

\subsection{General Compilation Algorithm}

\begin{algorithm}[H]
\caption{Generic compiler for an MO-1QFA}
\label{alg:mo-compiler}
\begin{algorithmic}[1]
\Require Automaton $A=(Q,\Sigma,\delta,q_0,F)$,\; input length $L$
\Ensure Circuit template that works for \emph{every} word $x\in\Sigma^L$
\State $n\gets\lceil\log_2|Q|\rceil$
\State Initialise $n$ qubits in $\ket{q_0}$
\For{$i=1$ \textbf{to} $L$}
   \State Insert placeholder gate $\boxed{U_{x_i}}$
\EndFor
\State Append two-outcome measurement $\{P_{\text{acc}},I-P_{\text{acc}}\}$
\end{algorithmic}
\end{algorithm}

The output is a \emph{template}: placeholders $\boxed{U_{x_i}}$
stand for “the unitary dictated by~$x_i$”.
Given an \emph{actual} word
$x=x_1\!\dots x_L$,  
each $\boxed{U_{x_i}}$ is replaced by the concrete $U_{x_i}$
and then (optionally) decomposed into native gates.

\subsection{Step-by-Step Examples}

\paragraph{Example 1: single-letter alphabet.}
Let
$Q=\{q_0,q_1\},\,
 \Sigma=\{a\},\,
 q_0$ initial,\,
 $F=\{q_1\}$,
and choose $U_a=H$.
For $L=1$ the compilation unfolds in three stages:

\begin{figure}[htb]
\centering
\begin{subfigure}{0.28\textwidth}
\centering
\begin{quantikz}[row sep=0.2cm]
\lstick{$\ket{q_0}$}& \gate[style={draw=blue!50,fill=blue!10}]{U_{x_1}}
                    & \meter{} \\
\end{quantikz}
\caption{Template ($L=1$)}
\end{subfigure}\hfill 
%
\begin{subfigure}{0.28\textwidth}
\centering
\begin{quantikz}[row sep=0.2cm]
\lstick{$\ket{q_0}$}& \gate{U_a} & \meter{} \\
\end{quantikz}
\caption{Instantiate ($x=a$)}
\end{subfigure}\hfill
%
\begin{subfigure}{0.28\textwidth}
\centering
\begin{quantikz}[row sep=0.2cm]
\lstick{$\ket{q_0}$}& \gate{H} & \meter{} \\
\end{quantikz}
\caption{Gate-level (synthesised)}
\end{subfigure}
\caption{Compilation stages for Example 1.
The last pane shows the fully synthesised circuit;
here $U_a=H$ needs no further decomposition.}
\label{fig:example1-stages}
\end{figure}

\paragraph{Example 2: two-symbol word of length $L=2$.}
Take
$Q=\{q_0,q_1,q_2\}$ ($n=2$ qubits),
$\Sigma=\{a,b\}$,
$U_a$ rotates $\ket{q_0}\!\leftrightarrow\!\ket{q_1}$,
$U_b$ swaps $\ket{q_1},\ket{q_2}$,
$F=\{q_2\}$.
Suppose the incoming word is $x=ab$.

\begin{figure}[htb]
\centering
\begin{subfigure}{0.30\textwidth}
\centering
\begin{quantikz}
\lstick{$\ket{q_0}$} & \gate[2,nwires={2}]{U_{x_1}} & \gate[2,nwires={2}]{U_{x_2}} & \meter{} \\
\lstick{$\ket{0}$} & & & \meter{} 
\end{quantikz}
\caption{Template ($L=2$ placeholders)}
\end{subfigure}\hfill
%
\begin{subfigure}{0.30\textwidth}
\centering
\begin{quantikz}
\lstick{$\ket{q_0}$}& \gate[2,nwires={2}]{U_a} & \gate[2,nwires={2}]{U_b} & \meter{} \\
\lstick{$\ket{0}$} & & & \meter{}
\end{quantikz}
\caption{Instantiate ($x=ab$)}
\end{subfigure}\hfill
%
\begin{subfigure}{0.30\textwidth}
\centering
\footnotesize
\begin{quantikz}
\lstick{$\ket{q_0}$}& \gate[2,nwires={2}]{\mathcal{R}_X(\theta)} & \swap{1} & \meter{}\\
\lstick{$\ket{0}$} & & \targ{} & \meter{}
\end{quantikz}
\caption{After synthesis\newline (example gate set)}
\end{subfigure}
\caption{Example 2: the compiler first produces a two-slot template,
then fills in $U_a,U_b$ once the word $ab$ is known, and finally
expands each unitary into native gates (here a rotation $\mathcal{R}_X$
and a SWAP).}
\label{fig:example2-stages}
\end{figure}

\paragraph{Example 3: cyclic automaton, $L=3$.}
For $Q=\{q_0,q_1,q_2\}$ and $\Sigma=\{a\}$ with
$U_a$ the 3-cycle $\ket{q_i}\mapsto\ket{q_{i+1\bmod 3}}$,
$F=\{q_0\}$, a length-3 input $x=aaa$ leads to:

\begin{figure}[htb]
\centering
\begin{subfigure}{0.30\textwidth}
\centering
\begin{quantikz}
\lstick{$\ket{q_0}$}& \gate{U_{x_1}} & \gate{U_{x_2}} & \gate{U_{x_3}} & \meter{}\\
\end{quantikz}
\caption{Template ($L=3$)}
\end{subfigure}\hfill
%
\begin{subfigure}{0.30\textwidth}
\centering
\begin{quantikz}
\lstick{$\ket{q_0}$}& \gate{U_a} & \gate{U_a} & \gate{U_a} & \meter{}\\
\end{quantikz}
\caption{Instantiate ($x=aaa$)}
\end{subfigure}\hfill
%
\begin{subfigure}{0.30\textwidth}
\centering
\begin{quantikz}
\lstick{$\ket{q_0}$}& \gate{U_a^3=\mathbb{I}} & \qw & \qw & \meter{}\\
\end{quantikz}
\caption{Optimised (note $U_a^3=\mathbb{I}$)}
\end{subfigure}
\caption{Example 3: after recognising that $U_a^3=\mathbb{I}$ the
compiler may cancel all three gates, yielding an identity.}
\label{fig:example3-stages}
\end{figure}

\medskip
In every case the final gate-level circuit is obtained by standard
synthesis algorithms (see Section~\ref{sec:quantum-gates-and-circuits}
for matrix-to-circuit compilation techniques),
guaranteeing that the circuit
accepts exactly the language recognised by the original MO-1QFA.
% ---------------------------------------------------------------------
