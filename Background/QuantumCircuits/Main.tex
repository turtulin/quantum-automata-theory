\section{Quantum Gates and Circuits}
\label{sec:quantum-gates-and-circuits}

The gate model formulates quantum computation as a sequence of reversible transformations that act on an ordered register of qubits. Each elementary transformation, or quantum logic gate, is represented by a unitary matrix that preserves the norm of the wavefunction and therefore the probabilistic interpretation of quantum states \cite{nielsen2005geometric}. By composing gates drawn from a finite universal set such as \gls{hadamard}, \gls{phase}, and \gls{cnot}, any unitary operator on a finite dimensional Hilbert space can be approximated to arbitrary accuracy, providing the foundation on which quantum algorithms like Shor's factoring routine and the \gls{qft} are constructed \cite{weinberg1995quantum,shor1994algorithms}.

Beyond abstract universality, physical realisations impose architectural constraints that influence gate granularity, qubit connectivity, and measurement timing. The criteria articulated by DiVincenzo identify coherent state preparation, high fidelity single and two qubit gates, and reliable read-out as indispensable requirements for scalable devices \cite{divincenzo2000physical}. Present \gls{nisq} processors satisfy these conditions only approximately, which motivates depth-aware decompositions, noise-adaptive compilation, and the explicit accounting of ancillary resources \cite{preskill2018quantum}. 

In the context of this thesis, quantum circuits serve as the executable target for the compilation of \glspl{qfa}. Each transition operator of an automaton is mapped to a concrete gate sequence, and every accepting projector is realised by a register measurement that interfaces classical control with coherent evolution. The remainder of this section surveys the primitive gate library, canonical circuit families, and decomposition techniques that together supply the hardware-agnostic substrate on which the automata-to-circuit translation of Chapter~\ref{chap:automata-to-circuits} is built.

\subsection{Common Quantum Gates}
\label{sec:common-quantum-gates}

Quantum logic gates are unitary operators acting on one or more qubits. 
They constitute the elementary instruction set of the gate model of quantum computation \cite{nielsen2010quantum}. 
A single-qubit gate realises a rotation of the Bloch vector, whereas a multi-qubit gate can generate entanglement, an intrinsically non-classical resource \cite{weinberg1995quantum}. 
This subsection recalls the canonical gate library, presents the corresponding matrices, and illustrates their circuit symbols .

\subsubsection*{Single-qubit gates: Pauli \(X\), \(Y\), \(Z\)}

The Pauli gates \(X\), \(Y\), and \(Z\) implement rotations by \(\pi\) about the \(x\), \(y\), and \(z\) axes of the Bloch sphere, respectively \cite{nielsen2010quantum}. 
In the computational basis \(\{\ket{0},\ket{1}\}\) they take the forms
\[
X=\begin{pmatrix}0&1\\[2pt]1&0\end{pmatrix},
\qquad
Y=\begin{pmatrix}0&-i\\[2pt]i&0\end{pmatrix},
\qquad
Z=\begin{pmatrix}1&0\\[2pt]0&-1\end{pmatrix}.
\]
The gate \(X\) exchanges the computational basis states and therefore plays the role of a quantum $NOT$ \cite{nielsen2005geometric}. 
The gate \(Z\) leaves \(\ket{0}\) invariant while mapping \(\ket{1}\) to \(-\ket{1}\); it is consequently referred to as a phase flip \cite{nielsen2005geometric}. 
The gate \(Y\) combines a bit flip with an intrinsic phase: \(Y\ket{0} = i\ket{1}\) and \(Y\ket{1} = -\,i\ket{0}\) \cite{nielsen2005geometric}. 
All three operators square to the identity (up to a global phase) and mutually anticommute, properties that underpin stabiliser-based error-correction protocols \cite{gottesman1997stabilizer}.

\begin{figure}[ht]
 \centering
 \begin{quantikz}
 \lstick{$\ket{q}$} & \gate{X} & \qw
 \end{quantikz}
 \caption{Circuit symbol for the Pauli \(X\) gate. Replacing the label by \({Y}\) or \({Z}\) yields the symbols for the remaining Pauli rotations.}
 \label{fig:x-gate}
\end{figure}

\subsubsection*{\glsentryfull{hadamard}}
The \gls{hadamard} gate realises a rotation by \(\tfrac{\pi}{2}\) about the axis \((x+z)/\sqrt{2}\) on the Bloch sphere \cite{deutsch1985quantum}. Its unitary matrix in the computational basis is
\[
\gls{hadamard}= \frac{1}{\sqrt{2}}
\begin{pmatrix}
1 & 1\\[2pt]
1 & -1
\end{pmatrix}.
\]
Acting on the basis states it produces the equal-weight superpositions
\(\gls{hadamard}\ket{0}= \ket{+}\) and
\(\gls{hadamard}\ket{1}= \ket{-}\), where 
\(\ket{\pm}= (\ket{0}\pm\ket{1})/\sqrt{2}\) define the Hadamard basis \cite{nielsen2010quantum}. 
A second application reverses the transformation since \(\gls{hadamard}^{2}=I\) up to global phase. 
Geometrically, the operation transfers quantum states between the \(Z\) and \(X\) axes of the Bloch sphere, sending \(\ket{0}\) and \(\ket{1}\) to the equator and vice versa. 
Because it satisfies \(\gls{hadamard} Z \gls{hadamard}=X\) and \(\gls{hadamard} X \gls{hadamard}=Z\), the gate exchanges the roles of bit-flip and phase-flip operators and is therefore indispensable for basis changes and interference patterns in algorithms such as Deutsch-Jozsa and Grover search \cite{deutsch1992rapid,grover1997quantum,nielsen2005geometric}.

\begin{figure}[ht]
 \centering
 \begin{quantikz}
 \lstick{$\ket{q}$} & \gate{H} & \qw
 \end{quantikz}
 \caption{Circuit symbol for the \gls{hadamard} gate .}
 \label{fig:h-gate}
\end{figure}

\subsubsection*{Phase rotations: \glsentryfull{phase}, $T$ and continuous \(R_{z}\)}

Phase rotations apply a relative phase to the state $\ket{1}$ while leaving $\ket{0}$ unchanged \cite{gottesman1997stabilizer}. 
The \gls{phase} gate introduces a phase of \(\pi/2\) and the $T$ gate a phase of \(\pi/4\); their unitaries are
\[
\gls{phase}= 
\begin{pmatrix}
1 & 0\\[4pt]
0 & i
\end{pmatrix},
\qquad
T= 
\begin{pmatrix}
1 & 0\\[4pt]
0 & e^{i\pi/4}
\end{pmatrix},
\]
so that
\(\gls{phase}\ket{1}=i\ket{1}\) and \($T$\ket{1}=e^{i\pi/4}\ket{1}\) \cite{nielsen2005geometric}. 
Because \(\gls{phase}^{2}=Z\) and \($T$^{4}=Z\), the operations may be viewed as fractional powers of the Pauli \(Z\) rotation \cite{bravyi2012magic}. 

Neither gate is involutory; instead their adjoints are
\[
 \gls{phase}^{\dagger} =
 \begin{pmatrix}
 1 & 0\\[4pt]
 0 & -i
 \end{pmatrix},
 \qquad
 T^{\dagger} =
 \begin{pmatrix}
 1 & 0\\[4pt]
 0 & e^{-i\pi/4}
 \end{pmatrix}.
\]

The discrete set \(\{\gls{hadamard},\gls{phase},\mathrm{CNOT}\}\) generates the Clifford group, which is not universal for quantum computation, but adjoining the non-Clifford $T$ yields a universal gate library capable of approximating any single-qubit unitary to arbitrary precision \cite{bravyi2012magic,dawson2005solovay}. 
In fault-tolerant architectures the cost of magic-state distillation makes the $T$ gate the dominant resource, so circuit depth is often quantified by its \(T\)-count \cite{eastin2013distilling}.

\begin{figure}[ht]
 \centering
 \begin{quantikz}
 \lstick{$\ket{q}$} & \gate{S} & \gate{T} & \qw
 \end{quantikz}
 \caption{Sequential application of an \gls{phase} gate followed by a $T$ gate.}
 \label{fig:st-sequence}
\end{figure}

More generally, a rotation about a Pauli axis \(\sigma_{\alpha}\in\{X,Y,Z\}\) through an angle \(\theta\) is
\[
R_{\alpha}(\theta)=\exp\bigl(-i\tfrac{\theta}{2}\sigma_{\alpha}\bigr),
\]
with explicit examples
\[
R_{x}(\theta)=
\begin{pmatrix}
\cos\bigl(\tfrac{\theta}{2}\bigr) & -i\sin\bigl(\tfrac{\theta}{2}\bigr)\\[4pt]
-i\sin\bigl(\tfrac{\theta}{2}\bigr) & \cos\bigl(\tfrac{\theta}{2}\bigr)
\end{pmatrix},
\qquad
R_{z}(\theta)=
\begin{pmatrix}
e^{-i\theta/2} & 0\\[4pt]
0 & e^{i\theta/2}
\end{pmatrix}.
\]
The parameterised family \(\{R_{y}(\theta), R_{z}(\phi)\}\) forms a convenient basis for variational circuits, and any single-qubit unitary admits the Euler decomposition 
\(U=R_{z}(\lambda)\,R_{y}(\theta)\,R_{z}(\phi)\) up to global phase \cite{nielsen2010quantum,kandala2017hardware}. 
Specialising \(\theta=0,\phi=\pi/2\) or \(\pi/4\) recovers the \gls{phase} and $T$ operations, respectively.

\subsubsection*{Multi-qubit gates: entangling operations}

Operations acting on two or more qubits can create quantum correlations that admit no classical description \cite{bell1964einstein}. 
Together with arbitrary single-qubit rotations they supply universality for quantum computation \cite{weinberg1995quantum}.

The \gls{cnot} gate flips the target qubit conditioned on the control being in the state $\ket{1}$ \cite{nielsen2010quantum}. 
In the ordered basis \{$\ket{00}$,$\ket{01}$,$\ket{10}$,$\ket{11}$\} its unitary is
\[
\gls{cnot}=
\begin{pmatrix}
1&0&0&0\\[4pt]
0&1&0&0\\[4pt]
0&0&0&1\\[4pt]
0&0&1&0
\end{pmatrix},
\]
implementing the map \(\ket{a,b}\mapsto\ket{a,a\oplus b}\). 
Applied to a superposition it generates entanglement, for example
\[
\bigl(\tfrac{\ket{0}+\ket{1}}{\sqrt{2}}\bigr)\otimes\ket{0}
\xrightarrow{\gls{cnot}}
\tfrac{\ket{00}+\ket{11}}{\sqrt{2}},
\]
a Bell state \cite{bell1964einstein}. 
\gls{cnot} is self-inverse and belongs to the Clifford group \cite{gottesman1997stabilizer}.

\begin{figure}[ht]
 \centering
 \begin{quantikz}
 \lstick{$\ket{c}$} & \ctrl{1} & \qw \\
 \lstick{$\ket{t}$} & \targ{} & \qw
 \end{quantikz}
 \caption{Circuit symbol for the \gls{cnot} gate with control \(\ket{c}\) and target \(\ket{t}\) .}
 \label{fig:cnot-gate}
\end{figure}

The \gls{cz} gate applies a phase flip to the joint state $\ket{11}$; its matrix is
\[
\gls{cz}=
\begin{pmatrix}
1&0&0&0\\[4pt]
0&1&0&0\\[4pt]
0&0&1&0\\[4pt]
0&0&0&-1
\end{pmatrix}
\]\cite{nielsen2010quantum}.
It is related to \gls{cnot} by a Hadamard conjugation on the target,
\(\gls{cz}_{(c,t)}=\gls{hadamard}_{t}\,\gls{cnot}_{(c,t)}\,\gls{hadamard}_{t}\) \cite{weinberg1995quantum}, 
and arises natively in several hardware platforms where controlled phase interactions dominate \cite{arute2019quantum}.

\begin{figure}[ht]
 \centering
 \begin{quantikz}
 \lstick{$\ket{c}$} & \ctrl{1} & \qw \\
 \lstick{$\ket{t}$} & \gate{Z} & \qw
 \end{quantikz}
 \caption{Symbol for the \gls{cz} gate .}
 \label{fig:cz}
\end{figure}

The \gls{swap} gate exchanges the quantum states of two qubits, 
\(\ket{a,b}\mapsto\ket{b,a}\), and is represented by the unitary matrix
\[
\gls{swap}=
\begin{pmatrix}
1&0&0&0\\[4pt]
0&0&1&0\\[4pt]
0&1&0&0\\[4pt]
0&0&0&1
\end{pmatrix}
\]\cite{nielsen2010quantum}. 
Although \(\gls{swap}\) is a genuine two-qubit entangling gate, its action can be realised
using exactly three \glspl{cnot}. 
A standard decomposition is 
\[
\gls{swap}_{(1,2)}=
\gls{cnot}_{1,2}\,
\gls{cnot}_{2,1}\,
\gls{cnot}_{1,2}
\]\cite{weinberg1995quantum}. 


\begin{figure}[ht]
 \centering
 \begin{quantikz}
 \lstick{$\ket{q_1}$} & \swap{1} & \qw \\
 \lstick{$\ket{q_2}$} & \targX{} & \qw
 \end{quantikz}
 \caption{Symbol for the \gls{swap} gate .}
 \label{fig:swap}
\end{figure}

The three-qubit \gls{toffoli} gate flips a target conditioned on two controls being in $\ket{1}$. 
It is universal for reversible classical computation \cite{bennett1973logical} and admits a fault-tolerant decomposition using six \glspl{cnot}, seven $T$ and single-qubit \gls{hadamard} gates \cite{amy2014polynomial}. 

\begin{figure}[ht]
 \centering
 \begin{quantikz}
 \lstick{$\ket{c_1}$} & \ctrl{2} & \qw \\
 \lstick{$\ket{c_2}$} & \ctrl{1} & \qw \\
 \lstick{$\ket{t}$} & \targ{} & \qw
 \end{quantikz}
 \caption{Symbol for the \gls{toffoli} gate .}
 \label{fig:toffoli}
\end{figure}

The \gls{cswap} gate swaps two targets conditioned on a single control and can be synthesised from \glspl{toffoli} \cite{fredkin1982conservative}. 
\begin{figure}[ht]
 \centering
 \begin{quantikz}
 \lstick{$\ket{c}$} & \ctrl{1} & \qw \\
 \lstick{$\ket{t_1}$} & \swap{1} & \qw \\
 \lstick{$\ket{t_2}$} & \targX{} & \qw
 \end{quantikz}
 \caption{Symbol for the \gls{cswap} gate \cite{fredkin1982conservative}.}
 \label{fig:cswap}
\end{figure}
\begin{figure}[!htbp]
 \centering
 \begin{quantikz}
 \lstick{$\ket{c}$} & \ctrl{2} & \ctrl{1} & \ctrl{2} & \qw \\
 \lstick{$\ket{t_1}$} & \ctrl{1} & \targ{} & \ctrl{1} & \qw \\
 \lstick{$\ket{t_2}$} & \targ{} & \ctrl{-1}& \targ{} & \qw
 \end{quantikz}
 \caption{Decomposition of the \gls{cswap} gate into three \glspl{toffoli} gates \cite{fredkin1982conservative}.}
 \label{fig:cswap-decomp}
\end{figure}

Any multi-qubit unitary can be approximated to arbitrary precision using single-qubit rotations together with \gls{cnot} or \gls{cz} gates \cite{weinberg1995quantum}. 
This decomposition forms the foundation of the quantum circuit model, where arbitrary computations are expressed as sequences of elementary operations. 
As a result, sets such as \(\{\gls{hadamard},T,\gls{cnot}\}\) are universal for quantum computing \cite{nielsen2010quantum}. 
High-level gates are routinely compiled into the \(R_{z}/R_{x}\)+\gls{cnot} basis, which aligns with hardware primitives such as IBM's \(U_{3}\)+\gls{cnot} set \cite{cross2017open,fedoriaka2025decomposition}.

\subsection{Types of Quantum Circuits}

Similar to their classical counterparts, quantum circuits can be naturally categorised according to their computational function and structural features. The circuit model of quantum computation supports a richer taxonomy reflecting the distinctive characteristics of quantum information, such as superposition, entanglement, and measurement-induced collapse, in contrast to the traditional classification of classical circuits into categories like combinational and sequential \cite{nielsen2010quantum}.

The representative classes of quantum circuits are surveyed in this subsection, with distinctions made based on the kind of gates employed, the presence of parameterisation, the function of measurement, and the interaction with classical control. To demonstrate the circuit structure and operational semantics of each category within the larger context of quantum algorithm design, a canonical example is given.

\subsubsection*{Single-Qubit Circuits}

A circuit that operates on a single qubit evolves the state vector on the Bloch sphere through one-qubit gates only. Such circuits are the elementary building blocks of the gate-based quantum-computing model and re-appear inside larger algorithms during state preparation, basis transformations and parameterised rotations used in variational ansätze \cite{kandala2017hardware}.

Every element of the special unitary group $\mathrm{SU}(2)$, up to a global phase, admits the Z-Y-Z Euler decomposition
\[
U \;=\; R_{z}(\alpha)\,R_{y}(\beta)\,R_{z}(\gamma),
\]
with real angles $\alpha,\beta,\gamma$. Hence any finite gate library that realises $R_{z}$ and $R_{y}$ is universal for single-qubit synthesis. A commonly employed minimal choice is the set $\{H,S,T\}$, where $H$ exchanges the computational and Hadamard eigen-bases, and the phase gates $S$ and $T$ supply the irrational phase that yields density on $\mathrm{SU}(2)$ \cite{weinberg1995quantum,dawson2005solovay}. On fault-tolerant hardware the cost of exact synthesis is dominated by the number of $T$ gates, while approximation to precision $\varepsilon$ can be achieved with $\mathcal{O}\bigl(\log^{c}(1/\varepsilon)\bigr)$ gates through the Solovay-Kitaev algorithm \cite{dawson2005solovay}.

Although a lone qubit cannot generate entanglement, single-qubit circuits are invaluable for hardware calibration, tomography and demonstrations of quantum behaviour such as phase accumulation and axis-dependent rotations \cite{barends2014superconducting}. The example below prepares a non-trivial state from $\ket{0}$, measures in the computational basis and routes the classical result to subsequent control logic.
\begin{figure}[htbp]
 \centering
 \begin{quantikz}[thin]
 \lstick{$\ket{0}$} & \gate{H} & \gate{T} & \gate{X} & \meter{} & \cw \\
 \end{quantikz}
 \caption{Single-qubit circuit that prepares the state $X\,T\,H\ket{0}$ and measures it in the computational basis; the outcome probabilities equal the squared moduli of the final amplitudes \cite{nielsen2010quantum}.}
 \label{fig:single_qubit_HTX}
 \end{figure}
 

The circuit realises the transformation $\ket{\psi}=X\,T\,H\ket{0}$ and then performs a projective measurement in the $\{\ket{0},\ket{1}\}$ basis; the outcome probabilities are the squared moduli of the amplitudes of $\ket{\psi}$ \cite{nielsen2010quantum}.

\subsubsection*{Multi-Qubit Circuits}

The circuit model attains its full expressive power only when the logical register hosts at least two qubits. As soon as an operation couples distinct lines the global evolution can no longer be factorised into single-qubit operators, and quantum correlations enter as a computational resource. A single entangling gate such as a \gls{cnot}, \gls{cz}, or \gls{swap} already maps separable basis states onto superpositions whose amplitudes refuse to decompose across subsystems \cite{weinberg1995quantum}. In the axiomatic framework of quantum theory entanglement supplies the nonclassical advantage that powers quantum algorithms, error-correcting codes, and digital simulation \cite{horodecki2009quantum}.

The canonical two-qubit routine prepares a Bell pair. Beginning from the computational basis state $\ket{00}$, a Hadamard rotation on the first line followed by a \gls{cnot} controlled by that line yields
\[
\frac{1}{\sqrt{2}}\bigl(\ket{00}+\ket{11}\bigr),
\]
one of the four maximally entangled Bell states \cite{bell1964einstein}. A single controlled operation therefore suffices to convert local superposition into nonlocal correlation.

\begin{figure}[ht]
 \centering
 \begin{quantikz}[thin]
 \lstick{$\ket{0}$} & \gate{H} & \ctrl{1} & \qw \\
 \lstick{$\ket{0}$} & \qw & \targ{} & \qw
 \end{quantikz}
 \caption{Preparation of a Bell state. A Hadamard gate acts on the first qubit and a controlled NOT entangles the register, producing the state $(\ket{00}+\ket{11})/\sqrt{2}$.}
 \label{fig:bell-prep}
\end{figure}

Realistic algorithms rely on considerably deeper entangling fabrics. Quantum adders, stabiliser encoders, oracle constructions, and variational ansätze all deploy cascades of \glspl{cnot} (or hardware-native equivalents) distributed across many lines \cite{gottesman1997stabilizer,shor1994algorithms,arute2019quantum}. On \gls{nisq} processors the cost of those layers dominates both runtime and accumulated error because two-qubit gates are typically an order of magnitude noisier than single-qubit rotations. Consequently layout-aware compilation, topological mapping, and gate-count optimisation focus primarily on reducing the depth and connectivity overhead of the entangling subgraph.

Entanglement is therefore at once the enabler and the principal bottleneck of scalable quantum computation. The synthesis of efficient multi-qubit circuits demands a balance between algebraic decompositions that minimise entangling depth and architectural constraints that restrict admissible couplings. Ongoing research in optimal synthesis, error mitigation, and noise-adaptive layout seeks to narrow this gap and deliver practical advantages for near-term workloads \cite{nielsen2010quantum}.

\subsubsection*{Parameterised (Variational) Circuits}

A \gls{pqc} is a quantum circuit whose elementary gates depend continuously on tunable parameters, typically rotation angles, that can be updated during classical post-processing \cite{peruzzo2014variational}. These circuits underpin the family of hybrid quantum-classical methods known as \glspl{vqa}, as well as many quantum machine-learning architectures \cite{cerezo2021variational}. By treating the gate angles as free variables, a classical optimiser iteratively adjusts them so as to minimise a cost functional estimated from repeated quantum measurements \cite{peruzzo2014variational}. The same constructs are also referred to as variational or ansatz circuits in the literature \cite{kandala2017hardware}.

Hardware-efficient parametrisations usually consist of alternating layers of single-qubit rotations and entangling gates, chosen to match the native connectivity of a given processor \cite{kandala2017hardware}. This layered design strikes a compromise between expressibility and implementability, since it allows the circuit depth to scale linearly with the number of layers while maintaining a regular pattern that is friendly to compilation. An elementary two-qubit layer of such an ansatz is displayed in Figure \ref{fig:pqc-two-qubit}. Each qubit undergoes a rotation about the $Y$ axis by an angle $\theta_{i}$, is entangled through a \gls{cnot}, and is finally rotated about the $Z$ axis by an angle $\phi_{i}$; the parameter set $\{\theta_{i},\phi_{i}\}$ is updated during optimisation \cite{peruzzo2014variational}. Stacking $L$ identical layers enlarges the reachable manifold of states and therefore the representational power of the ansatz, albeit at the expense of an increased number of variational parameters and a higher exposure to noise \cite{sim2019expressibility}.

\begin{figure}[ht]
 \centering
 \begin{quantikz}[thin]
 \lstick{$\ket{0}$} & \gate{R_{y}(\theta_{1})} & \ctrl{1} & \gate{R_{z}(\phi_{1})} & \qw \\
 \lstick{$\ket{0}$} & \gate{R_{y}(\theta_{2})} & \targ{} & \gate{R_{z}(\phi_{2})} & \qw
 \end{quantikz}
 \caption{A single two-qubit layer of a hardware-efficient \gls{pqc}. Local $Y$-rotations with angles $\theta_{1}$ and $\theta_{2}$ create superposition, a controlled-NOT entangles the register, and $Z$-rotations with angles $\phi_{1}$ and $\phi_{2}$ supply additional degrees of freedom.}
 \label{fig:pqc-two-qubit}
\end{figure}

\glspl{pqc} constitute the workhorse for ground-state estimation via the \gls{vqe}, for combinatorial optimisation in the Quantum Approximate Optimisation Algorithm, and for discriminative or generative models in quantum machine learning \cite{farhi2014quantum}. They exemplify the hybrid paradigm in which a quantum processor provides a differentiable, high-dimensional function while a classical computer searches the associated parameter space \cite{cerezo2021variational}. Research directions now focus on enhancing expressibility without incurring barren-plateau gradients, mitigating noise through tailored ansätze, and devising derivative estimation schemes that reduce measurement overhead \cite{sim2019expressibility}.

\subsubsection*{Measurement-Based Circuits}

In the measurement-based quantum computation model, also known as the one-way quantum computer, computation is driven entirely by adaptive single-qubit measurements performed on a highly entangled resource state \cite{raussendorf2001one}. A universal resource is the two-dimensional cluster state, although lower-dimensional graphs suffice for restricted tasks and proof-of-principle demonstrations \cite{briegel2009measurement}. The protocol separates state preparation from logical processing: first a cluster is created via nearest-neighbour controlled-$Z$ gates; subsequently, a sequence of measurements, whose bases are classically adjusted in real time according to earlier outcomes, realises the desired unitary evolution up to Pauli by-product operators \cite{raussendorf2003measurement}.

To illustrate the mechanism, consider a linear three-qubit cluster. Each qubit is initialised in the $\ket{+}$ eigenstate of $X$, entangled with its neighbour through a controlled-$Z$, and then the first two qubits are measured while the third remains unmeasured. Conditional feed-forward ensures that the randomness inherent in projective measurement translates into deterministic logical action on the output qubit.

Because any gate-based circuit admits translation to a measurement pattern on a suitable cluster, measurement-based quantum computation is computationally equivalent to the standard circuit model \cite{briegel2009measurement}. The separation between offline entanglement generation and online adaptive measurements has motivated fault-tolerant schemes compatible with photonic and modular architectures, where long-range two-qubit gates are challenging but high-fidelity single-qubit operations and measurements are readily available \cite{raussendorf2003measurement}.

\begin{figure}[ht]
 \centering
 \begin{quantikz}[thin]
 \lstick{$\ket{+}$} & \ctrl{1} & \qw & \meter{} & \cw \\
 \lstick{$\ket{+}$} & \targ{} & \ctrl{1} & \meter{} & \cw \\
 \lstick{$\ket{+}$} & \qw & \targ{} & \qw
 \end{quantikz}
 \caption{Three-qubit linear cluster used to demonstrate measurement-based quantum computation. After entangling the register with controlled-$Z$ gates, qubits 1 and 2 are measured in suitably chosen bases. Feed-forward Pauli corrections on qubit 3 map the stochastic measurement results onto a deterministic logical operation equivalent to a single-qubit gate.}
 \label{fig:mbqc-linear-cluster}
 \end{figure}
 

 \subsubsection*{Hybrid Quantum-Classical Circuits}

 In the \gls{nisq} era, noise levels and qubit counts limit the depth of purely quantum workloads, motivating \gls{hqc} circuits in which coherent evolutions alternate with classical post-processing \cite{preskill2018quantum}. A prototypical instance is the \gls{vqe}: the quantum processor prepares a parameterised state and measures observables, while a classical optimiser updates the parameters so as to minimise the energy expectation value \cite{cerezo2021variational}. Real-time feedback is likewise essential in active quantum error correction, where measurement outcomes (syndrome bits) are interpreted by classical logic that decides the corrective operations to apply before further decoherence accrues \cite{kelly2015state}.
 
 \gls{hqc} circuits exploit complementary strengths. Quantum circuitry explores Hilbert spaces that grow exponentially with qubit number, whereas classical computation affords flexible control flow, arbitrary bandwidth memory, and mature optimisation heuristics \cite{preskill2018quantum}. A single optimisation step consists of executing the quantum circuit, collecting measurement data to evaluate the cost function, and using a classical routine to compute new parameters for the subsequent quantum run \cite{cerezo2021variational}. The global algorithm is therefore a sequence of partial quantum circuits interleaved with classical kernels rather than a monolithic unitary \cite{preskill2018quantum}. Nonetheless, circuit diagrams can depict one iteration explicitly by inserting mid-circuit measurement symbols and classically controlled gates, making the data flow transparent \cite{kelly2015state}.
 
 \begin{figure}[ht]
 \centering
 \begin{quantikz}[row sep={0.6cm,between origins},column sep=0.7cm,thin]
 \lstick{$\ket{0}$} & \gate{R_{y}(\theta_{1})} & \ctrl{1} & \gate{R_{z}(\phi_{1})} & \meter{} & \cw \\
 \lstick{$\ket{0}$} & \gate{R_{y}(\theta_{2})} & \targ{} & \gate{R_{z}(\phi_{2})} & \meter{} & \cw
 \end{quantikz}
 \caption{Single iteration of a \gls{vqe} rendered as an \gls{hqc} circuit. Parameterised rotations and entangling gates prepare the quantum state; projective measurements extract expectation values that are forwarded to a classical optimiser, which in turn updates the angles $\{\theta_{i},\phi_{i}\}$ before the next invocation of the circuit.}
 \label{fig:hqc-loop}
\end{figure}
 
 Hybrid strategies generalise beyond energy minimisation. The quantum approximate optimisation algorithm tunes discrete decision variables, adaptive phase-estimation tightens eigenvalue estimates, and Bayesian feedback protocols steer quantum sensors towards the Heisenberg limit, all through iterative quantum-classical loops \cite{cerezo2021variational}. Current research optimises the communication latency between the two domains, integrates machine-learning controllers that predict favourable parameter updates, and develops analytic gradient estimators that reduce the number of quantum evaluations required per step. Mastering such co-designed workflows is essential for extracting useful performance from near-term processors and for paving a smooth transition towards fully fault-tolerant architectures.
 
\subsection{Example Quantum Algorithms as Circuits}
\label{subsec:example_algorithms_circuits}

Quantum circuits provide a concrete framework in which the abstract principles of superposition, interference and entanglement manifest as algorithmic resources. By arranging single-qubit rotations and entangling two-qubit gates into ordered layers, designers can synthesise unitary transformations that would be impractical to describe or simulate classically. To illustrate this correspondence we revisit three paradigmatic algorithms routinely cited as milestones in quantum computing: the \gls{dj} algorithm, Grover amplitude amplification and the Quantum Fourier Transform (\gls{qft}) \cite{nielsen2010quantum}. The \gls{dj} algorithm exploits phase kickback to distinguish balanced from constant Boolean oracles in a single query, establishing an exponential gap in query complexity. Grover's procedure rephrases the search task as a coherent rotation toward the marked state, achieving quadratic speed-up through iterative applications of an oracle-controlled phase inversion and a diffusion operator. The \gls{qft} realises a basis change that maps computational-basis vectors to phase-encoded superpositions, serving as the central subroutine in period-finding and phase-estimation protocols. Each example exposes a distinct mechanism by which a modest set of one- and two-qubit gates outperforms the best known classical procedures \cite{preskill2018quantum}. The presentation below emphasises the circuit topologies, the precise ordering of gates, the accumulation and cancellation of relative phases, the interference patterns induced by measurement and the explicit scaling of gate counts with register size; these details are indispensable when later mapping higher-level computational models such as \glspl{qfa} onto executable hardware circuits that must respect connectivity, coherence times and error budgets.

\subsubsection*{Deutsch-Jozsa Algorithm}

The \gls{dj} algorithm furnishes one of the earliest demonstrations of an exponential separation between quantum and deterministic classical query complexity \cite{deutsch1992rapid}. The promise problem is to decide whether a Boolean function $f:\{0,1\}^n\to\{0,1\}$ is constant or balanced, given oracle access to $U_f:\ket{x}\ket{y}\mapsto\ket{x}\ket{y\oplus f(x)}$ \cite{cleve1998quantum}. A deterministic classical algorithm requires $2^{\,n-1}+1$ queries in the worst case, whereas the quantum procedure returns a definitive answer with a single evaluation \cite{deutsch1992rapid}.

The register comprises $n$ input qubits initialised in $\ket{0^{\otimes n}}$ and one work qubit prepared in $\ket{1}$ \cite{nielsen2010quantum}. A layer of Hadamard gates places the input into an equal superposition and the work qubit into $\ket{-}=(\ket{0}-\ket{1})/\sqrt 2$ \cite{deutsch1992rapid}. After the oracle acts, a second Hadamard layer on the input register implements an $n$-qubit Walsh-Hadamard transform that converts relative phases into computational-basis amplitudes \cite{cleve1998quantum}. Measuring the input yields $\ket{0^{\otimes n}}$ if $f$ is constant and any other string if $f$ is balanced, achieving certainty in a single query \cite{deutsch1992rapid}.

Because $U_f$ leaves the work qubit in $\ket{-}$ its effect can be viewed as a relative phase $(-1)^{f(x)}$ applied to $\ket{x}$ \cite{deutsch1992rapid}. The second Hadamard layer therefore interferes amplitudes constructively on $\ket{0^{\otimes n}}$ when all phases coincide (constant case) and destructively otherwise (balanced case), exemplifying global property extraction by quantum interference \cite{nielsen2010quantum}.

\begin{figure}[h]
    \centering
    \begin{quantikz}
    \lstick{$\ket{0}_{q_0}$} & \gate{H} & \gate[wires=3]{U_f} & \gate{H} & \meter{} & \cw \\
    \lstick{$\ket{0}_{q_1}$} & \gate{H} &                        & \gate{H} & \meter{} & \cw \\
    \lstick{$\ket{1}_{q_2}$} & \gate{H} &                        & \qw      & \qw      &
    \end{quantikz}
    \caption{Circuit representation of the \gls{dj} algorithm. The oracle $U_f$ acts on both the input and work registers. The final measurement discriminates between constant and balanced Boolean functions by detecting constructive or destructive interference on $\ket{0^{\otimes n}}$ \cite{deutsch1992rapid, cleve1998quantum, nielsen2010quantum}.}
    \end{figure}
    
\subsubsection*{Grover's Search Algorithm}

Grover's algorithm addresses the unstructured search problem by locating a single marked element among $N=2^{n}$ possibilities with a quadratic query reduction relative to classical exhaustive search \cite{grover1997quantum}. The procedure begins by preparing the uniform superposition $\ket{s}=H^{\otimes n}\ket{0^{\otimes n}}$, on which two reflections are alternately applied: an oracle reflection $U_{f}=I-2\ket{\omega}\bra{\omega}$ that flips the phase of the marked state $\ket{\omega}$ and a diffusion reflection $D=2\ket{s}\bra{s}-I$ that inverts amplitudes about the global mean \cite{brassard2000quantum}. The combined Grover operator $G=D\,U_{f}$ effects a rotation by angle $2\theta$ in the two-dimensional subspace spanned by $\ket{\omega}$ and $\ket{s_{\perp}}$, where $\sin\theta=1/\sqrt{N}$; after $r\approx\frac{\pi}{4}\sqrt{N}$ iterations the probability of observing $\ket{\omega}$ peaks at virtually unity, establishing an optimal $O(\sqrt{N})$ query complexity bound proved tight by the hybrid argument \cite{boyer1998tight}. At the circuit level each iteration consists of $n$ Hadamards, an $n$-qubit controlled-phase oracle and a sequence $H^{\otimes n}X^{\otimes n}Z_{0^{n}}X^{\otimes n}H^{\otimes n}$ realising the diffusion step with only one- and two-qubit gates using an $(n-1)$-control $Z$ on the all-zero state \cite{nielsen2010quantum}. Ancilla-free decompositions of the multi-control $Z$ are feasible at $O(n)$ Toffoli-depth using standard gate libraries, while fault-tolerant implementations can trade depth for $T$-count by leveraging relative-phase Toffolis and measurement-based uncomputation. Resource estimation therefore shows that a full Grover search over $n=40$ qubits, sufficient for key-search problems, would require roughly $10^{6}$ $T$ gates when executed on a surface-code protected architecture, orders of magnitude below the cost of competing classical brute-force methods. The canonical circuit and a worked example for $n=2$ are given below, with $\ket{11}$ designated as the marked item.

\begin{figure}[ht]
 \centering
 \begin{quantikz}
 \lstick{$\ket{0}^{\otimes n}$}
 & \gate{H^{\otimes n}}
 & \gate{U_{f}}
 & \gate{D}
 & \meter{} \qwbundle{n}
 \end{quantikz}
 \caption{Grover iteration circuit for an $n$-qubit register showing the oracle reflection $U_{f}$ followed by the diffusion operator $D$.}
 \label{fig:grover_generic}
 \end{figure}
 
 \begin{figure}[ht]
 \centering
 \begin{quantikz}
 \lstick{$\ket{0}$} & \gate{H} & \ctrl{1} & \gate{H} & \gate{X} & \ctrl{1} & \gate{X} & \gate{H} & \meter{} & \cw \\
 \lstick{$\ket{0}$} & \gate{H} & \gate{Z} & \gate{H} & \gate{X} & \targ{} & \gate{X} & \gate{H} & \meter{} & \cw
 \end{quantikz}
 \caption{Explicit two-qubit Grover circuit with $\ket{11}$ marked, illustrating the oracle phase flip via a controlled-$Z$ and the subsequent diffusion step.}
 \label{fig:grover_two_qubit}
 \end{figure}
 

The first Hadamards create the equal-amplitude superposition, the controlled-$Z$ implements the oracle phase flip on $\ket{11}$, and the remaining gates perform diffusion. Repeating the entire block the prescribed number of times concentrates amplitude on the marked state, demonstrating how coherent amplitude amplification converts modest gate counts into a quadratic performance advantage over classical search.

\subsubsection*{Quantum Fourier Transform (QFT)}

The (\gls{qft}) is the unitary analogue of the classical discrete Fourier transform, acting directly on the amplitudes of an $n$-qubit register to encode computational-basis indices into relative phases. It serves as the core subroutine in algorithms such as Shor integer factoring and quantum phase estimation, where interference in the Fourier basis extracts periodicity and eigen-phase information from a black-box unitary. Formally the transform maps
\[
\ket{j}\;\longmapsto\;\frac{1}{2^{n/2}}\sum_{k=0}^{2^{n}-1}e^{2\pi i jk/2^{n}}\ket{k},
\]
thereby re-expressing the computational basis in a phase-weighted superposition that can be measured to reveal frequency-domain structure. An exact gate-level realisation decomposes into $n$ layers, each beginning with a Hadamard on qubit $q_\ell$ followed by controlled-phase rotations $R_{k}= \text{diag}(1,e^{2\pi i/2^{k}})$ from $q_\ell$ onto successively less-significant qubits; this yields the canonical $n(n+1)/2$ gate count that is asymptotically optimal for a fully coherent Fourier transform without ancillary qubits. In practice final qubit-order reversal is implemented by a sequence of SWAPs or absorbed into classical post-processing, while approximate variants truncate small-angle rotations to reduce depth on noisy hardware at the cost of bounded fidelity loss. 

\begin{figure}[ht]
\centering
\begin{quantikz}
\lstick{$\ket{q_0}$} & \gate{H} & \ctrl{1} & \ctrl{2} & \qw & \qw & \qw & \meter{} & \cw \\
\lstick{$\ket{q_1}$} & \qw & \gate{R_2} & \qw & \gate{H} & \ctrl{1} & \qw & \meter{} & \cw \\
\lstick{$\ket{q_2}$} & \qw & \qw & \gate{R_3} & \qw & \gate{R_2} & \gate{H} & \meter{} & \cw
\end{quantikz}
\caption{Three-qubit \gls{qft} circuit without final SWAP gates.}
\label{fig:qft_three_qubit}
\end{figure}

%The sequence of Hadamards and controlled rotations realises the Fourier basis change, while measurements can be deferred until after optional qubit-order reversal.

The exact circuit thus achieves an exponential data-size compression relative to a naïve classical implementation that would require $2^{n}$ complex multiplications, and its highly regular structure makes it an ideal benchmark for compilation strategies and fault-tolerant resource estimation in larger algorithmic pipelines that incorporate \glspl{qfa} and other automata-based primitives.

\subsection{Decomposition of Arbitrary Unitaries into Quantum Circuits}
\label{subsec:unitary_decomposition}

Quantum circuit synthesis asks how an arbitrary $n$-qubit unitary $U\in\mathrm{U}\left(2^{n}\right)$ can be realised exactly or approximately by a finite sequence of gates drawn from a universal library, typically the Clifford\,+\,$T$ set. The task is fundamental for compilation, resource estimation and verification, because every high-level quantum algorithm must eventually be expressed at this gate level. Exact synthesis is information-theoretically constrained: a generic unitary carries $4^{\,n}-1$ real parameters, so any gate sequence that exhausts the reachable space requires $\Omega\left(4^{n}\right)$ elementary rotations \cite{shende2005synthesis}. 

A constructive strategy meeting this lower bound factorises $U$ into a product of two-level unitaries that each alter amplitudes in a two-dimensional subspace spanned by computational basis states $\ket{i}$ and $\ket{j}$ \cite{reck1994experimental}. Fedoriaka's elimination algorithm arranges these two-level factors so that $\ket{i}$ and $\ket{j}$ differ in exactly one qubit \cite{fedoriaka2025decomposition}. Under this condition every factor becomes a single-qubit rotation on the differing qubit, controlled on the remaining $n-1$ lines. The rotation is therefore a fully controlled gate $C^{\,n-1}\bigl(R_{y}(\theta)\bigr)$ or $C^{\,n-1}\bigl(R_{z}(\phi)\bigr)$ that can be further decomposed into $\mathcal{O}(n)$ \gls{cnot}s and single-qubit phases, or implemented directly on platforms with native multi-control support \cite{weinberg1995quantum}. 

Choosing the ordering of basis states according to a binary Gray code guarantees that successive pairs differ in exactly one bit, allowing the two-level factors to march systematically across the matrix while never increasing the Hamming distance beyond one \cite{bullock2003arbitrary}. Conceptually the matrix is first permuted by a Gray-order permutation $P$, the product $PUP^{\mathsf{T}}$ is decomposed, and the permutation is later undone by relabeling or by a fixed swap network whose depth scales linearly with $n$. The algorithm applies $\tfrac12\,2^{n}\left(2^{n}-1\right)$ two-level rotations, giving a gate count $\Theta\left(4^{n}\right)$ that saturates the optimal asymptotic bound up to constant factors \cite{shende2005synthesis}. 

Several practical optimisations reduce the constant overhead. Consecutive $X$ controls on the same line often cancel, global phases can be deferred to a single final $R_{1}$ rotation and sparsity in $U$ eliminates whole classes of two-level operations \cite{fedoriaka2025decomposition}. When $U$ is block diagonal or tensor factorable the synthesis cost drops to polynomial in $n$; for example, if $U=\bigotimes_{k=1}^{n}U_{k}$ only $n$ single-qubit gates are required \cite{weinberg1995quantum}. 

Alternative exact techniques achieve the same asymptotic footprint while sometimes yielding circuits with more regular structure. The \gls{csd} recursively partitions $U$ into uniformly controlled rotations, leading to the quantum Shannon family of circuits that are well suited to optimisation by templates and peephole rules \cite{maslov2008quantum}. Householder-reflection methods similarly match the $\Theta\left(4^{n}\right)$ bound but distribute entangling gates differently, which can be advantageous under restricted qubit connectivity \cite{shende2005synthesis}. 

In applications where approximation is acceptable the Solovay-Kitaev theorem guarantees that any exact decomposition can be truncated and then refined to precision $\varepsilon$ with length $\mathcal{O}\bigl(\log^{c}(1/\varepsilon)\bigr)$ over a fixed universal set, with $c\approx3.97$ independent of $n$ \cite{dawson2005solovay}. State-of-the-art compilers layer numerical optimisation on top of analytical backbones such as \gls{csd}. They invoke iterative KAK factorizations, constraint solvers or the ZX-calculus to compress depths further on noisy intermediate-scale quantum hardware while monitoring accumulated approximation error \cite{heyfron2018efficient}. 

Exact Gray-code elimination therefore provides a conceptually transparent synthesis that is provably optimal in the worst case, yet the exponential scaling highlights why practical quantum advantage relies on structured operators such as the \gls{qft}, oracle reflections or variational ansätze whose decompositions grow only polynomially with problem size \cite{preskill2018quantum}. 


\begin{example}[Two-qubit random unitary]  
Consider the numerically specified $4\times4$ matrix
\[
U_{\mathrm{ex}}=
\begin{pmatrix}
0 & \tfrac{1}{\sqrt2} & \tfrac{1}{\sqrt2} & 0 \\
1 & 0 & 0 & 0 \\
0 & 0 & 0 & -1 \\
0 & \tfrac{1}{\sqrt2} & -\tfrac{1}{\sqrt2} & 0
\end{pmatrix},
\]
labelled in Gray order $\{\ket{00},\ket{01},\ket{11},\ket{10}\}$.  
Fedoriaka's procedure eliminates the off-diagonal entries in three steps:
\begin{enumerate}
\item Apply $C^{1}\bigl(R_{y}(\theta_{1})\bigr)$ on $q_{0}$ controlled by $q_{1}$ to zero the $(1,0)$ element.  
\item Apply $C^{1}\bigl(R_{z}(\phi_{1})\bigr)$ on $q_{0}$ controlled by $q_{1}$ to adjust the relative phase.  
\item Apply a single-qubit phase $R_{z}(\gamma)$ on $q_{1}$ to fix the global determinant.  
\end{enumerate}
A minimal gate-level implementation is illustrated in Figure \ref{fig:fedoriaka_twoqubit}. After local cancellations the circuit contains two \gls{cnot}s and five single-qubit rotations, underscoring that small instances can be substantially cheaper than the worst-case bound.

\begin{figure}[ht]
\centering
\begin{quantikz}
\lstick{$q_{0}$} & \gate{R_{z}(\phi_{1})} & \ctrl{1} & \gate{R_{y}(\theta_{1})} & \ctrl{1} & \qw \\
\lstick{$q_{1}$} & \gate{R_{z}(\gamma)} & \targ{} & \qw & \targ{} & \qw
\end{quantikz}
\caption{Gray-code two-qubit decomposition of $U_{\mathrm{ex}}$. The fully controlled rotations emerge as \gls{cnot} sandwiches with single-qubit phases.}
\label{fig:fedoriaka_twoqubit}
\end{figure}
\end{example}

\begin{example}[Block-diagonal three-qubit unitary]
Let  
\[
U_{\mathrm{blk}}=
\begin{pmatrix}
U_{0} & 0 \\ 0 & U_{1}
\end{pmatrix},
\qquad
U_{0}=R_{y}(\alpha),\;
U_{1}=R_{z}(\beta),
\]
where the most significant qubit indexes the blocks. The matrix is already sparse; only two fully controlled single-qubit rotations are needed:
\[
C^{2}\bigl(R_{y}(\alpha)\bigr)\quad\text{and}\quad
C^{2}\bigl(R_{z}(\beta)\bigr).
\]
Each decomposes into six \gls{cnot}s and four elementary rotations in the Clifford\,+\,$T$ set. The total depth therefore scales linearly with $n$ instead of exponentially, demonstrating how exploitable structure in $U$ suppresses the gate count far below the Gray-code worst case.
\end{example}

\begin{example}[Tensor-product unitary]
If $U=U_{1}\otimes U_{2}\otimes\dots\otimes U_{n}$ the circuit is simply the parallel application of the $n$ single-qubit matrices $U_{k}$. No entangling gates are required, so the synthesis cost is exactly $n$ elementary rotations. This instance saturates the best possible scaling for a non-trivial $n$-qubit operator, confirming that exponential overhead is not intrinsic but rather tied to entangling structure.
\end{example}

These examples translate the abstract complexity analysis into concrete gate sequences, supplying reference circuits and resource counts that can be validated experimentally or within automated compilers.

