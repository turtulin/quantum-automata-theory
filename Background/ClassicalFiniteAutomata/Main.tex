\section{\glsentrylongpl{cfa} and Formal Languages}\label{sec:cfa-languages}

Finite automata occupy the lowest computational tier: machines whose
memory is bounded by a constant independent of the input length.  They
nevertheless underpin lexical analysis, model checking and the design
of communication protocols
\cite{AhoHopcroftUllman1974,Sipser2012}.  This section moves from
general language–grammar notions to four concrete automaton models,
highlighting their historical development, formal properties and
representative examples.

\subsection{Languages, Grammars and Regularity}\label{subsec:foundations}

Finite automata study begins with the algebra of words.  The discussion
below moves from the atomic notion of an alphabet to the structural
power of regular grammars, concluding with Kleene’s correspondence
between grammars, expressions and machines.

\begin{definition}[Alphabet]\label{def:alphabet}
A non-empty finite set $\Sigma$ of symbols is called an alphabet
\cite{HopcroftUllman1979}.
\end{definition}

\begin{definition}[String and Concatenation]\label{def:string}
A string, or word, over $\Sigma$ is a finite sequence
$w=a_{1}a_{2}\dots a_{n}$ with $a_{i}\in\Sigma$.  
The empty word is denoted $\varepsilon$.  
Concatenation $u\cdot v$ appends the sequence of $v$ to $u$
\cite{HopcroftUllman1979}.
\end{definition}

\begin{notation}
The set of all words over $\Sigma$ forms the free monoid
$\Sigma^{\ast}$ under concatenation with identity $\varepsilon$
\cite{HopcroftUllman1979}.
\end{notation}

\begin{definition}[Formal Language]\label{def:language}
Any subset $L\subseteq\Sigma^{\ast}$ is a language
\cite{HopcroftUllman1979}.
\end{definition}

\begin{concept}[Regular Grammar]\label{concept:regular-grammar}
A type-3 grammar in Chomsky’s hierarchy generates the regular languages
\cite{Chomsky1959}.
\end{concept}

\begin{theorem}[Kleene Correspondence]\label{thm:kleene}
The following families coincide:
\begin{enumerate}
  \item languages generated by type-3 grammars,
  \item languages denoted by regular expressions,
  \item languages recognised by \glspl{cfa}.
\end{enumerate}
\cite{Kleene1956}
\end{theorem}

\begin{proposition}[Closure of Regular Languages]\label{prop:closure}
Let ${\cal R}$ denote the class of regular languages.  
If $L_{1},L_{2}\in{\cal R}$ then so are
$L_{1}\cup L_{2}$, $L_{1}\cap L_{2}$, $\overline{L_{1}}$,
$L_{1}\,L_{2}$ and $L_{1}^{\ast}$  
\cite{HopcroftUllman1979}.
\end{proposition}

\begin{example}[Simple Regular Language]\label{ex:reg-lang}
For $\Sigma=\{0,1\}$ the set
$L=\{w\in\Sigma^{\ast}\mid w\text{ ends in }1\}$ is regular because it
is described by the regular expression $\Sigma^{\ast}1$
\cite{HopcroftUllman1979}.
\end{example}

\begin{observation}\label{obs:why-regular-matters}
Regular languages admit linear-time membership tests and deterministic
finite-state representations; hence they are widely used in lexical
tokenisers and hardware controllers \cite{AhoHopcroftUllman1974}.
\end{observation}

\subsection{Deterministic Finite Automata}\label{subsec:dfa}

Deterministic machines give the clearest computational intuition: at
every step the next state is uniquely determined by the current state
and the scanned symbol \cite{HopcroftUllman1979}.

\begin{definition}[Deterministic Finite Automaton]\label{def:dfa}
A \gls{dfa} is the quintuple
$M=(Q,\Sigma,\delta,q_{0},F)$ with
$\delta\colon Q{\times}\Sigma\to Q$,
$q_{0}\in Q$ and $F\subseteq Q$
\cite{HopcroftUllman1979}.
\end{definition}

\begin{proposition}[Unique Computation Path]\label{prop:dfa-path}
For every $w\in\Sigma^{\ast}$ the extended map
$\hat{\delta}(q,\varepsilon)=q$ and
$\hat{\delta}(q,aw)=\hat{\delta}(\delta(q,a),w)$
produces exactly one path in $M$
\cite{HopcroftUllman1979}.
\end{proposition}

\begin{theorem}[Myhill–Nerode]\label{thm:mn-dfa}
A language is regular if and only if the right-invariant relation
$x\sim_{L}y\Longleftrightarrow
\forall z\in\Sigma^{\ast}\colon xz\in L\Leftrightarrow yz\in L$
has finitely many equivalence classes
\cite{Nerode1958}.
\end{theorem}

\begin{example}[Even $a$’s]\label{ex:dfa-even}
Figure~\ref{fig:dfa-even-a} shows the \gls{dfa} recognising
$L=\{w\mid \text{the number of }a\text{ is even}\}$
\cite{HopcroftUllman1979}.
\end{example}

\begin{observation}[Practical role]\label{obs:dfa-app}
\glspl{dfa} underlie lexical tokenisers, hardware controllers and regex
engines that insist on linear-time, deterministic matching
\cite{AhoHopcroftUllman1974}.
\end{observation}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[->,>=stealth,node distance=30mm]
      \node[state,initial,accepting] (qe) {$q_{\mathrm{even}}$};
      \node[state]                   (qo) [right of=qe] {$q_{\mathrm{odd}}$};
      \path (qe) edge[loop above] node {$b$} (qe)
            (qo) edge[loop above] node {$b$} (qo)
            (qe) edge[bend left]  node {$a$} (qo)
            (qo) edge[bend left]  node {$a$} (qe);
    \end{tikzpicture}
    \caption{\gls{dfa} recognising words with an even number of $a$’s
    \cite{HopcroftUllman1979}.}
    \label{fig:dfa-even-a}
\end{figure}

\subsection{Nondeterministic Finite Automata}\label{subsec:nfa}

Nondeterminism lets an automaton explore many futures simultaneously,
shrinking state space at the cost of branching semantics
\cite{RabinScott1959}.

\begin{definition}[Nondeterministic Finite Automaton]\label{def:nfa}
A \gls{nfa} is $M=(Q,\Sigma,\delta,q_{0},F)$ with
$\delta\colon Q{\times}\Sigma\to\mathcal{P}(Q)$
\cite{RabinScott1959}.
\end{definition}

\begin{lemma}[Acceptance Criterion]\label{lem:nfa-accept}
$M$ accepts $w$ iff there exists a sequence
$q_{0}\to q_{1}\to\dots\to q_{|w|}\in F$ such that
$q_{i+1}\in\delta(q_{i},w_{i+1})$
\cite{HopcroftUllman1979}.
\end{lemma}

\begin{theorem}[Subset Construction]\label{thm:subset}
Every \(n\)-state \gls{nfa} has an equivalent \gls{dfa}
with at most \(2^{n}\) states
\cite{RabinScott1959}.
\end{theorem}

\begin{example}[Length-one words]\label{ex:nfa-length1}
The \gls{nfa} in Figure~\ref{fig:nfa-figure} accepts
$\Sigma^{1}$ using $\epsilon$-transitions
\cite{RabinScott1959}.
\end{example}

\begin{observation}[Succinctness]\label{obs:nfa-size}
There exist languages whose minimal \gls{nfa} is linear in $n$ while
every equivalent \gls{dfa} requires $2^{n}$ states
\cite{AhoHopcroftUllman1974}.
\end{observation}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[->,>=stealth,node distance=27mm]
      \node[state,initial] (q0) {$q_{0}$};
      \node[state]         (q1) [above right of=q0] {$q_{1}$};
      \node[state]         (q2) [below right of=q0] {$q_{2}$};
      \node[state,accepting] (qf) [right of=q1] {$q_{f}$};
      \path (q0) edge[bend left]  node[above] {$\epsilon$} (q1)
            (q0) edge[bend right] node[below] {$\epsilon$} (q2)
            (q1) edge node[above] {$a,b$} (qf)
            (q2) edge node[below] {$a,b$} (qf);
    \end{tikzpicture}
    \caption{\gls{nfa} accepting all words of length one
    \cite{RabinScott1959}.}
    \label{fig:nfa-figure}
\end{figure}

\subsection{Probabilistic Finite Automata}\label{subsec:pfa}

By weighting transitions with probabilities, \glspl{pfa} capture
one-way finite-state stochastic processes
\cite{Rabin1963}.

\begin{definition}[Probabilistic Finite Automaton]\label{def:pfa}
A \gls{pfa} is
$M=(Q,\Sigma,\{\delta(a)\}_{a\in\Sigma},\mathbf{i},F)$
where each
$\delta(a)\in[0,1]^{Q\times Q}$ is row-stochastic and
$\mathbf{i}\in[0,1]^{Q}$ is an initial distribution
\cite{Rabin1963}.
\end{definition}

\begin{concept}[Cut-point Language]\label{concept:cutpoint}
Given $\lambda\in[0,1]$,
$L(M,\lambda)=\{w\mid \Pr_{M}(w)>\lambda\}$ is the cut-point language
of $M$ \cite{Rabin1963}.
\end{concept}

\begin{theorem}[Bounded-error Regularity]\label{thm:pfa-bounded}
If \(\lambda\) is isolated (bounded error) then
\(L(M,\lambda)\) is regular \cite{Paz1971}.
\end{theorem}

\begin{proposition}[Undecidability]\label{prop:pfa-undec}
Equivalence and emptiness are undecidable for unbounded-error
\glspl{pfa} \cite{Paz1971}.
\end{proposition}

\begin{example}[Unary PFA]\label{ex:pfa-unary}
Figure~\ref{fig:pfa-figure} shows a \gls{pfa} over $\{a\}$ accepting
$a^{k}$ for $k\ge2$ with cut-point $\lambda=0.5$
\cite{Rabin1963}.
\end{example}

\begin{observation}[Historical note]\label{obs:pfa-history}
\glspl{pfa} foreshadow probabilistic Turing machines and
finite-memory Markov models used in speech recognition
\cite{Rabin1963,Paz1971}.
\end{observation}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[->,>=stealth,node distance=37mm]
      \node[state,initial] (q0) {$q_{0}$};
      \node[state,accepting] (q1) [right of=q0] {$q_{1}$};
      \path (q0) edge[loop above] node {$a/0.5$} (q0)
            (q0) edge[bend left]  node {$a/0.5$} (q1)
            (q1) edge[loop above] node {$a/1$} (q1);
    \end{tikzpicture}
    \caption{\gls{pfa} that, with cut-point $\lambda=0.5$, recognises
    $\{a^{k}\mid k\ge 2\}$ \cite{Rabin1963}.}
    \label{fig:pfa-figure}
\end{figure}

%-----------------------------------------------------------------------
% 4 Two-way finite-automata variants
%-----------------------------------------------------------------------
\subsection{Two-way variants}\label{subsec:two-way}

Allowing the tape head to reverse direction enriches operational
behaviour without extending expressive power beyond regular languages
\cite{Shepherdson1959}.

\begin{definition}[Two-way Head]\label{def:two-way-head}
On alphabet $\Sigma_{\Box}=\Sigma\cup\{\Box\}$ a head movement is
$d\in\{-1,0,1\}$, signifying left, stay, right
\cite{Shepherdson1959}.
\end{definition}

\begin{definition}[2DFA, 2NFA, 2PFA]\label{def:2dfa2nfa2pfa}
\begin{enumerate}
\item \gls{2dfa}: deterministic
$\delta\colon Q{\times}\Sigma_{\Box}\to Q{\times}\{-1,0,1\}$.
\item \gls{2nfa}: the same domain but $\delta$ returns a set of
state–move pairs \cite{RabinScott1959}.
\item \gls{2pfa}: for each input symbol a row-stochastic distribution
over state–move pairs \cite{Freivalds1982}.
\end{enumerate}
\end{definition}

\begin{theorem}[Expressive Power]\label{thm:two-way-reg}
Bounded-error \glspl{2pfa}, as well as \glspl{2dfa} and \glspl{2nfa},
recognise exactly the regular languages
\cite{Freivalds1982,Shepherdson1959}.
\end{theorem}

\begin{proposition}[Simulation Costs]\label{prop:two-way-cost}
Simulating an \(n\)-state \gls{2dfa} or \gls{2nfa} by a one-way
\gls{dfa} may incur \(2^{\mathcal{O}(n\log n)}\) states
\cite{Shepherdson1959,RabinScott1959}.  
A bounded-error \gls{2pfa} needs $\mathcal{O}(n^{2})$ states when
converted to a one-way \gls{pfa} \cite{DworkStockmeyer1992}.
\end{proposition}

\begin{example}[Sketch 2PFA]\label{ex:2pfa-sketch}
Figure~\ref{fig:2pfa-figure} illustrates a bounded-error
\gls{2pfa} \cite{Freivalds1982}.
\end{example}

\begin{observation}[Bidirectional processing]\label{obs:two-way-app}
Two-way automata model stream processors that reread data, a capability
used in text editors and network-protocol verification
\cite{Shepherdson1959}.
\end{observation}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[->,>=stealth,node distance=39mm]
      \node[state,initial] (q0) {$q_{0}$};
      \node[state]         (q1) [right of=q0] {$q_{1}$};
      \node[state,accepting] (qf) [right of=q1] {$q_{f}$};
      \path (q0) edge[loop above] node {$b,0/0.7$} (q0)
            (q0) edge[bend left] node {$a,+1/0.3$} (q1)
            (q1) edge[loop above] node {$b,-1/0.5$} (q1)
            (q1) edge[bend left] node {$a,+1/0.5$} (qf)
            (qf) edge[loop above] node {$a,b,0/1$} (qf);
    \end{tikzpicture}
    \caption{Sketch of a bounded-error \gls{2pfa}
    \cite{Freivalds1982}.}
    \label{fig:2pfa-figure}
\end{figure}
