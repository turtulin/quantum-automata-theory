\chapter{Conclusion}
\label{chap:conclusion}

This study has revisited the theoretical foundations and the practical compilation of \glspl{qfa}. Starting from a detailed taxonomy that unifies over thirty years of scattered literature, we framed the principal one-way variants, namely the \gls{mo-1qfa} and the \gls{mm-1qfa}, within a single terminology. The resulting classification clarifies relations among models and supplies a consistent language for future analyses.

Building on that framework, we introduced a compilation pipeline that translates high-level \gls{qfa} specifications into architecture-independent quantum circuits. The pipeline separates template generation from parameter instantiation: templates encode the automaton structure once, whereas numerical parameters are loaded either offline or at run time. This separation permits the execution of \glspl{qfa} on present \gls{nisq} devices without sacrificing portability or reusability.

By producing executable gate-level designs for both \glspl{mo-1qfa} and \glspl{mm-1qfa}, the thesis bridges finite-memory language recognisers and quantum software stacks, advancing the theoretical understanding of automaton-to-circuit translation and delivering practical tools for embedding quantum recognisers into larger workflows. This convergence of automata theory and circuit design reinforces the role of \glspl{qfa} as foundational elements of quantum computing and opens avenues for systematic, automata-driven programming on forthcoming hardware generations.


Future investigations may target two-way and hybrid automata, automated minimisation, and quantitative studies of expressive trade-offs in quantum-classical hybrids. Moreover, the thesis does not explicitly analyse the space/time complexity of the compiled circuits, the number of gates, the depth of the circuit, and how many qubits are used as the number of states of the automaton or the input length grows. This is necessary to understand whether the compilation framework scales for realistic languages. 

